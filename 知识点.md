# 20170510
## 模块
内置模块
---
    http模块
        html.createServer(function(req,res){
            req 代表客户端
                req.url  请求路径
                req.method  获取提交方式

            res 代表服务端
                res.end(); 结束响应并可以返回一些信息回送给客户端（类型只能为字符串与buffer）
                res.setHeader("Content-Type","text/html;charset=utf-8");设置返回给客户端的界面信息
                res.statusCode    修改状态码
                res.setHeader("Access-Control-Allow-Origin","*");
                以上方式可以解决跨域访问接口，但需要后台配合，可以在server中设置可以访问的域名
                在服务端没有../
        }).listen(端口,function(){
            监听端口
        });

    url模块
        url.parse(地址,true);    解析url，第二个参数为true，可以将query解析成key:value形式
    fs模块 ----  文件系统
        fs.readFileSync("文件路径",设置编码格式);  同步方式读取文件内容，默认是buffer
        fs.readFile("文件路径",设置编码格式,function(err,data){
            if(err){
                console.log(err);
            }else{
                console.log(data);
            }
        }); 异步方式读取文件内容
        fs.exist("文件地址"); 根据路径异步判断文件是否存在  ，返回布尔类型
        fs.existsSync("./1.html");根据路径同步判断文件是否存在  ，返回布尔类型
        fs.writeHead(状态码,{location:"地址"});  重定向
     path模块
        path.resolve("./a.js"); 获取当前文件的绝对路径
第三方模块
---
    mime模块
        mime.lookup();  解析出指定文件的mine类型
自定义模块
---
    导入
        let server2 = require("./server2.js");  导入自定义模块需要按照相对路径查找
            模块引入有缓存，即使引入多次，也是执行一次，走的是缓存
        require .cache[path.resolve("./a.js")];
            模块清除缓存,路径为绝对路径，cache是模块缓存信息对象 属性名是模块的绝对路径
    导出
        第一种导出方法
            module.exports.sum = sum;   导出自定义模块
            module.exports = {
                sum:sum,
                abc:abc
            };
        第二种导出方法
            module.exports = exports;  默认导出的都是module.exports指向的空间地址
            exports.name = "zhs";//给默认module.exports添加了一个属性
            exports = {//重新创建了一个空对象(地址），改变默认module.exports的空间地址，不能进行批量导出
                name :"zhs"
            };
        总结：module.exports可以导出批量，但是exports无法批量导出，原因是两者指向的空间地址不同
        每个js模块其实导出都是自己的module.exports这个模块
注意：
---
    第三方模块和内置模块只需要根据名称查找即可
    模块的查找方式是从当前的目录下一级一级向上查找，直到找到根目录为止
    第三方模块安装方法    npm install mime --save

## ajax创建封装
```
function createAjax(){
    if(window.XMLHttpRequest){
        var oAjax = new XMLHttpRequest();
    }else{
        if(new ActiveXObject("Microsoft.XMLHTTP")){
            var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
        }else if(new ActiveXObject("Msxml2.XMLHTTP")){
            var oAjax = new ActiveXObject("Msxml2.XMLHTTP");
        }else if(new ActiveXObject("Msxml3.XMLHTTP")){
            var oAjax = new ActiveXObject("Msxml3.XMLHTTP");
        }
    }
    return oAjax;
}

let xhr = createAjax();
xhr.open("GET","",true);
xhr.responseType = "json";
xhr.onreadystatechange = function(){
    if(this.readyState===4 && /^2\d{2}$}/.test(this.status)){
        console.log(this.response);
    }
};
xhr.send();
```


# 20170511
## ajax
    async javascript  and xml   web交互技术异步获取局部刷新
    xml   与数据有关 （数据格式）
ajax步骤
---
    1,创建ajax对象
        var oAjax = new XMLHttpRequest();
    2,打开一个接口，建立链接通道
        oAjax.open("请求方式","请求地址","是否异步");
            请求方式：get，post，delete，head，put
                http请求方式
                    * get       从后端获取资源
                    * post      推送数据给后端
                    * delete    删除服务器端资源
                    * head      获取响应头
                    * put       更新服务端数据
                    get与post区别
                        1,缓存问题
                            get存在缓存问题
                                解决办法：只需要在请求url？_=随机数(Math.random())，时间戳(new Date().getTime())
                            post不存在缓存问题
                        2,传输数据大小
                            get
                                get是将需要发送后端的数据拼接到url？name=zhs&age=10 大小限制
                                标准浏览器 8kb
                            post
                                通过请求体向后台发送数据，没有大小限制
                                xhr.send(JSON.Stringify(数据));  数据格式为字符串
                        3,安全问题
                            前端数据处理方式
                                get     请求是将数据拼接到url后面，容易被url劫持
                                post    请求是将数据放在请求体中，比较安全
                            后端数据处理方式
                                获取get方式请求发送
                                    url.parse("文件路径",true).query;
                                获取post请求发送的数据
                                    var str = '';
                                    req.on("data",function(data){//接受前端请求体里发送的数据（数据是一点点发送的，不是整体发送过来）
                                        str+=data;
                                    });
                                    req.on("end",function(){
                                           console.log(str);//接收数据完毕之后执行end   str属于string类型
                                           JSON.parse(str);  将字符串转换为对象
                                    });
            请求地址：url/接口
            是否异步：true 异步（async）    false 同步(sync)
    3,监听ajax请求状态
        oAjax.onreadystatechange = function(){
            ajax状态 0 - 4   readyState
                * 0 uninit 未初始化 创建了ajax对象 但没有调用open
                * 1 loading 载入 发送请求 调用了open和send
                * 2 loaded 载入完成 接受响应原始数据完成 准备解析
                * 3 交互 将响应回来的原始数据 解析为 客户端 可以调用的数据挂载到responseText responseXML
                * 4 done 完成  可以供客户端调用 并且http状态码为200
            if(this.readyState===4 && /^2\d{2}$/.test(this.status)){
                console.log(this.responseText);
            }
        };
    4,发送请求
        oAjax.send();

        JSON.stringify(obj);  将对象转化为字符串
        JSON.parse(str);    将字符串转换为对象

Jquery ajax参数分析
---
    $.ajax({
        url:url, //请求地址
        type:"GET", //请求方式    JQ1.9版本以下用method
        beforeSend:function(xhr){
          //发送请求之前  触发
        },
        data:{
            //向服务端发送的数据
        },
        cache:true, //是否缓存，true 缓存   false不缓存
        async:true, //是否异步,true 异步  false  同步
        jsonp:"",//重写jsonp的请求url中回调函数key的名称
        jsonpCallback:"",//指定jsonp回调函数的名称
        dataType:"text", //接受的数据解析格式  xhr.responseText
        context:window,//指定success里面上下文this
        success:function(result){ //成功的回调函数
            console.log(result);
            //this默认指向  当前options
        },
        timeout:3000,//设置请求超时时间，如果超时会触发error  xhr.timeout  触发  xhr.ontimeout = function
        error:function(err){    //请求出错
            console.log(err);
        },
        complete:function(xhr){
            //不管提交成功与否，都会执行
        }
    });

对象合并
---
    es6方法
        Object.assign(obj1,obj2);   obj2对象的内容会覆盖obj1

    for(var attr in obj2){
        obj1[attr] = obj2[attr];
    }

# 20170513
    什么是node？
        node就是一个运行环境，可以用js运行在服务端，浏览器端不能操作本地文件
    node特点（js是单线程）
        非阻塞异步I/O
        commonjs规范(node自带的模块化)
            require()  引入模块
            module.exports   导出模块
        基于V8引擎(浏览器端分为js引擎和webkit渲染引擎)
        npm 包管理器(bower)

    node安装
        Mac  安装 homebrew
            在终端输入下面安装 Homebrew
        查看是否安装成功
            cmd  node -v
        配置系统环境变量
            右键计算机属性->高级系统设置->环境变量->系统变量->配置path->node安装路径
        node 进入交互模式解析器
            命令行中输入 node
            ctrl+c    退出
        webstorm 配置node环境
            settings  ->
            找到nodeJs and npm  ->
            将enable转为disable
    js文件运行方式
        webstorm中运行方式
            在文件中 右键 --run 文件.js
        cmd中运行方式
            cmd---在文件目录下打开cmd命令窗口----输入node 文件.js

    global  node环境下的全局对象
    this    node环境下的this是空对象
        原因是node运行的js代码最终是被包装在一个函数中，而不是放在全局中，所以this没有指向global

    node模块
        1,内置模块
            fs  文件系统模块
                fs.readFileSync("读取的文件","编码格式");   同步读取   默认格式buffer格式(二进制数据流格式)
                    同步函数基本上都有返回值
                fs.readFile("读取的文件","编码格式",function(err,result){
                    err 错误信息
                    result  读取到的结果
                    if(err){
                        throw Error(err);
                    }esle{
                        console.log(result);
                    }
                });     异步读取   异步读取基本上没有返回值

                fs.writeFile("文件路径","写入内容",{flag:w},function(err){
                    flag    w为默认参数，写入并将原有覆盖
                            a  在原有内容的基础上进行添加
                    encoding    指定写入的编码格式
                    写入的内容只有两种格式：string类型与buffer格式
                    console.log(err);
                }); 异步写入 向文件中添加内容

                fs.writeFileSync("文件路径","写入内容",{flag:w});   同步写入

            http模块  搭建server
                http.createServer(function(req,res){
                    req 代表客户端请求对象
                        req.url  请求路径
                        req.method  获取提交方式

                    res 代表服务端响应对象
                        res.end(); 结束响应并可以返回一些信息回送给客户端（类型只能为字符串与buffer）
                        res.setHeader("Content-Type","text/html;charset=utf-8");设置返回给客户端的界面信息(字符编码格式，mime类型)
                        res.statusCode    修改状态码
                }).listen(端口,function(){
                    端口范围    0~65535
                    console.log("监听端口");
                });

                http-server
                    全局安装
                        npm install http-server -g
                        使用
                            在当前目录下打开命令行，输入http-server
                            http-server -p 8080     指定一个端口号（默认是8080）
            url模块
                url.parse(urlStr,true);
                    第二个参数默认为false，query会以&进行拼接显示数据，设置为true时，query会以对象的形式显示
            querystring模块
                qs.parse(字符串,"分隔符");       将字符串转化为对象
                qs.stringify(对象,"拼接符");     将对象转化为字符串
        2,第三方模块
            通过npm下载的模块
                npm安装save区别
                    代码依赖/生产依赖
                        npm install vue --save
                    开发依赖
                        npm install webpack -save
            查找机制：从当前文件夹开始查找，找不到，向上级查找，一级一级查找，直到根目录为止
                console.log(module);
                paths:
                   [ 'E:\\node\\node\\20170513\\node_modules',
                     'E:\\node\\node\\node_modules',
                     'E:\\node\\node_modules',
                     'E:\\node_modules' ] }
        3,自定义模块
            自己创建的js文件
            文件与文件之间的依赖(如a与b文件)
                b文件引入a文件
                    b文件
                        require("./a.js");  根据路径引入
                    a文件
                        module.exports.sum = sum;  导出a文件中的方法
                        console.log(this===module.exports);//true

# 20170514
## ！！！！ES6
    跨域
        同源策略 --- 限制XMLHttpRequest请求（src,href等不存在跨域）
            协议，域名，端口三者一致
            三者只要有一个不同就是跨域
            主要存在于两个页面交互中，url不同
jsonp原理
---
    客户端设置跨域
    利用script标签不存在跨域，我们给src属性url地址，只要能找到就会将js引入进来
    我们把请求的url地址设为script标签的src属性，并且和后台定义的一个字段，将我们全局中的函数名传给后台 cb=callback
    jsonp跨域只支持get请求

    CORS跨域资源共享，需要服务端设置
        res.setHeader("Access-Control-Allow-origin","*");
            * 代表任何人
            "http://localhost:6000"  单独设置某个服务跨域


# 20170516
## VUE
    vue    渐进式框架   MVVM模式
模式
---
    MVC ----- angularJs  ---- 单向通信
        model   数据层 保存数据
        view    视图层 用户界面
        controller  控制器 业务逻辑
        过程：v-c-m-v
            视图层：用户操作界面通过DOM事件--->
            控制器：向控制器发送指令，执行相应的业务逻辑，--->
            数据层：通过数据层保存或者修改状态，--->
            视图层：再由数据层反馈给视图层
    MVVM  ----- VUE  ----- 双向数据绑定
        m   model   数据模型 保存数据
        v   view    视图层 用户界面
        vm  viewModel   视图模型(将视图和数据绑定在一起)
        过程：
            v -> vm - m
            m -> vm - v
            1,view改变，会导致vm改变，vm改变了会同种model数据源状态
            2,m数据源更新了，会通知vm，vm发生改变，v会自动跟着变化

vue安装
---
    初始化一个package.json
        nmp init -y
    下载vue
        nmp install vue --save

## VUE
    vue压缩和不压缩
            开发版：通常开发阶段 引入不压缩版  有报错提示 便于调试
            生产版：压缩版 vue.min.js  是没有报错提示的

初始化vue
---
    初始化一个Vue的根实例，它需要一个参数对象，挂载元素el  数据data， 方法，生命周期钩子 template
```
var vm = new Vue({
    el:"#app",  挂载元素  指定应用范围 不能挂载在html或者body上
    data:{  数据，挂载数据 相当于viewModel
        title:"hello vue.js"
    }
});
```

认识Vue
---
    1,vm根实例会暴露出一些属性和方法  前面$
        console.log(vm.$data===obj);
            true 两者指向同一空间地址
        obj.title = "hello,zhs";
        vm.say = "hello,tong";
            不能再实例生成后添加不存在的属性，可以提前定义属性，后赋值

    2,console.log(vm.$el);  //<div id="box"></div>
        获取挂载元素 相当于document.getElementById("box");
        console.log(vm.$el===document.getElementById("box"));  true


    3,vm.$watch("title",function(newVal,oldVal){
        监听数据状态方法
            参数1是新值，参数2是旧值，监听的数据改变的时候触发，并且将新值和旧值当做参数传递进来
        console.log(newVal,oldVal);
    });

    4,vm.$mount("#box");
        手动指定挂载元素（如果在初始化vue实例时，没有设置el，可以通过以下方法进行挂载）

    5,模板语法
        1：编译模板方式
            {{ val }}   在html中插入值
                可以在{{}}进行表达式操作
                    三目运算符
                        {{ context?context:"没有值存在" }}
                        {{ context=context||"没有值存在" }}
                    简单运算
                        <h5>{{ num+100 }}</h5>
                    一些表达式
                        <h6>{{ text.toUpperCase() }}</h6>
                        <h2>{{ arr.join().slice(2) }}</h2>


                不可以在{{}}中使用的内容
                    不能使用操作语句
                        {{ var name = 100 }}
                        if判断 {{ if(true){title} }}

            <标签 v-text="val"></标签>  采用这种方式是避免了闪烁，看不到编译前的内容
                会将元素原有的内容替换掉
        2：v-cloak避免了闪烁，也可以使用双花括号插入值
        3：插入html片段  尽量少用，避免xss攻击
            <div v-html="htmlStr"></div>
        4:动态绑定属性  v-bind
            完整写法：<a v-bind:href="link">百度</a>
            简写:<a :href="link">百度</a>
        5,模板语法分析
            <div id="box">{{ title }}</div>
            <script>
                var oBox = document.getElementById("box");
                var title = "hello world";
                var reg = /\{\{(.*)\}\}/;
                var html = oBox.innerHTML;
                html = html.replace(reg,function(){
                    console.log(arguments[1]);
                    return eval(arguments[1]);
                });
                oBox.innerHTML = html;
            </script>

    6,v-for
          要循环谁，就把v-for写在谁身上
          in可以换成of
              v-for="val of arr"
          获取索引值
              遍历数组
                  v-for="(每一项内容,每一项索引) in arr"
              遍历json对象
                  v-for="(属性值,属性名) in json"
              遍历二维数组（既包含数组有包含对象）
                  item代表数组中的每一项
                  <li v-for="item in result">{{item.name}}:{{item.age}}</li>

    7,v-if  操作DOM元素
       true    插入
       false   移出

    8,v-show  操作元素样式显示隐藏
       true    显示
       false   隐藏

    9,v-once  一次性插入
       <div v-once>{{text}}</div>

    10,v-model
        v-model 应用于表单中做双向数据绑定，文本框radio,checkbox,select,textarea
        以下为常见的几种v-model的使用情况
            <!--第一种情况-->
                <input type="text" v-model="name" />
                <p>{{name}}</p>
            <!--第二种情况-->
                <input type="checkbox" v-model="val" />
                <p>{{val}}</p>
            <!--第三种情况-->
                React:<input type="checkbox" value="A" v-model="arrs">
                Vue:<input type="checkbox" value="B" v-model="arrs">
                Node:<input type="checkbox" value="C" v-model="arrs">
                <p>{{arrs}}</p>
            <!--第四种情况-->
                用户名：<input type="text" v-model="user.name">
                电话：<input type="text" v-model="user.tel">
                <ul>
                    <li>{{user.name}}</li>
                    <li>{{user.tel}}</li>
                </ul>

            new Vue({
                el:"#box",
                data:{
                    name:"",
                    val:"",
                    arrs:[],
                    user:{
                        name:"",
                        tel:""
                    }
                }
            });
    11,v-on 绑定事件
        完整写法：v-on:事件类型="处理函数";
        简写：@click = "处理函数";
        <button v-on:click="say('abc',$event)">点击</button>
            1,函数不传递参数是可以不加括号
            2,不传参数的情况下，默认第一个参数就是事件对象$event
        new Vue({
            el:"#box",
            methods:{   当前视图用到的方法存放在methods  存在事件的方法 集合
                say:function(e,event){
                    console.log(this);   this指向当前vue根实例
                    console.log(event.target);  获取触发事件的元素
                }
            }
        });
数组方法
---
    1, 查找id为2的那一项，如果找到那一项，会将那一项返回出去
        arr.find(function(item){
            return item.id === 2;
        });
    2,将符合条件的项过滤出来
        arr.filter(function (item) {
            return item.id>2
        });
    3,会将每一次的返回值作为新数组中的每一项，常用来修改一个数组的内容
        arr.map(function(item){
            if(item.id===2){
                return {id:20}
            }
            return item;
        });
# 20170517
## git安装
    git更新课件
        git pull origin master

    git拷贝项目到本地
        在新建目录下右键 git bash
        输入 git clone 地址

事件修饰符
---
    1,阻止冒泡传播,在事件后面添加stop即可
        原生方式：通过event对象下event.stopPropagation();
        v-on:click.stop = "clild";
    2,阻止默认行为,在事件后添加prevent即可
        原生方式：通过event对象下event.preventDefault();
        v-on:click.prevent = "link";
            a标签默认行为
                <a href="http://www.baidu.com" @click.prevent.stop="link">百度</a>
            表单默认行为
                原生方式：onsubmit = "return false";
                vue方式：
                    先阻止表单默认行为，在进行ajax操作
                    <form action="http://www.baidu.com"  @submit.prevent>
                        <button type="submit">提交</button>
                    </form>

    3,既阻止冒泡，又要阻止默认行为，在事件后进行串联即可
        @click.prevent.stop="link"
    4,将事件流机制有冒泡转为捕获
        @click.capture="center";
    5,一次性事件，事件只触发一次 --- 支持vue版本2.1以上
        @click.once="once";

按键修饰符
---
    1,根据某个按键触发事件,可以用@keyup.键值
        <input type="text" @keyup.enter="fn">
        <input type="text" @keyup.keyCode="fn">
        vue封装的几个常用按键
            @keyup.enter    回车
            @keyup.space    空格
            @keyup.esc      ESC
            @keyup.delete   delete
            @keyup.tab      tab
            @keyup.up       上
            @keyup.down     下
            @keyup.left     左
            @keyup.right    右
        自定义按键
            定义：Vue.config.keyCodes.q = 81;
            使用：<input type="text" @keyup.q="fn">

style与class
---
    1,操作style
        动态绑定样式
            对象写法 {key:"value"}
                <div v-bind:style="{width:'100px',height:'100px',backgroundColor:'red'}"></div>
                <div v-bind:style="styleObj"></div>
                    将styleObj对象存在vue.data中
            数组写法
                <div v-bind:style="[styleObj,styleObj2]"></div>
                    在vue.data中存放两个样式对象，在使用时用数组
    2,操作class
        动态绑定class   (动态绑定的class可以与静态class共存)
            <div :class="s1"></div>
                前提将class名称存在vue.data中

            对象写法
                class名称：布尔值(如果为true选用当前class名，如果为false不选择当前class名)
                <div :class="{style1:isActive,style2:!isActive}">对象写法</div>
            数组写法
                <div :class="[s1,font]"></div>  s1与font此时data对象中定义的属性名称
                <div :class="['style1','font']"></div> 还可以直接放字符串（即class名）
                可以进行三元运算
                    <div :class="[isActive?s2:s1]">三元运算写法</div>

            对象+数组写法
                <div :class="[{style1:!iActive,style2:isActive},'font']">对象+数组写法</div>

computed    计算属性
---
    computed通过一个属性计算出来一个新的属性，当这个属性变化时，新的属性也会跟着变化

    computed中的内容是函数，正常该函数分为两种状态，getter和setter
        如果只有一个函数时，默认采用get
        computed:{
            函数名称：{
                get:function(){
                    函数获取的时候会触发 get
                },
                set:function(){
                    函数的属性值被修改时被触发 set
                }
            }
        }

watch
---
    watch   监听属性 监听一些数据的状态
        new Vue({
            el:"#box",
            data:{
                val:"",
                title:"",
                obj:{name:"zhs",age:20}
            },
            watch:{
                val:function(newVal,oldVal){},
                title:"listen",
                obj:{
                    handler:function(newVal,oldVal){},
                    deep:true
                }
            }
            methods:{
                listen:function(newVal,oldVal){}
            }
        });
lifecycle
---
    lifecycle   生命周期    钩子函数
        实例状态
            beforeCreate:function(){
                实例创建前
            }
            created:function(){  请求数据在这个阶段
                实例创建完成
            }
        数据状态
            beforeMount:function(){
                数据挂载前
            }
            mounted:function(){
                数据挂载完成
            }
        实例销毁
            beforeDestroy:function(){
                销毁前
            }
            destroyed:function(){
                销毁完成
            }
            vm.$destroy();  销毁组件 实例  通过这个方法触发销毁
        data状态 更新
            beforeUpdate:function(){
                数据更新前
            }
            updated:function(){
                数据更新完成
            }
过滤器
---
    定义：
        自定义过滤器必须放在生成实例之前
        Vue.filter("过滤器名称",function(val){
            arguments参数
            默认第一个参数是当前的值
            return  结果;
        });
    使用：
        {{ message|过滤器名称 }}

什么是组件？
---
    组件是vue的一个强大功能，扩展html元素 代码重复利用

    组件分类
        全局组件 ------ 可以应用于各个el范围
            初始化实例前注册组件
                    组件名称：小写，可以是多个单词my-component，可以是单个单词comp,不能与原始标签名重复
                    参数对象；配置组件的结构（template），行为（methods），数据（data函数） ,计算属性，生命周期
            使用template标签创建模板，将模板标签id放在对象template属性后即可调用
                <template id="temps">
                    <div>
                        <h3>我是全局模板，欢迎使用</h3>
                    </div>
                </template>
                template:"#temps",
            注册：
                Vue.component("组件名称",{
                    template:"<h3 @click='say'>{{title}}</h3>",
                        template组件中只能有一个根元素
                    data:function(){    此data不是对象，是函数
                       return {title:"我是一个组件"}   必须将数据返回
                    },
                    methods:{
                        say:function(){
                            alert(1);
                        }
                    },
                    computed:{
                    },
                    created:function () {
                        alert("创建组件完成");
                    }
                });
            使用：
                <组件名称></组件名称>
        局部组件  -----  只能应用于当前el的范围
            注册：
                new Vue({
                    el:"#box",
                    components:{
                        "自定义标签名":{
                            template:"<h1>我是一个局部组件</h1>"
                        }
                    }
                });
            使用：
                <自定义标签名></自定义标签名>

# 20170518
组件嵌套
---
    根实例被称之为父组件
    new Vue({
        el:"#box",
        如果根实例没有指定模板，默认会将div#box作为模板，如果定义了template模板，会将模板渲染在界面上，会替换div#Box
        template:"<div><h3>父组件图书商城</h3><child></child><child></child></div>",
        components:{
            child:{
                可以将子组件模板直接放入父组件模板中
                template:"<div><h4>子组件图书列表</h4><book1></book1><book2></book2></div>",
                components:{
                    book1:{
                        template:"<p>署名：vue.js <end></end></p>",
                        components:{
                            end:{
                                template:"<div><button>购买</button></div>"
                            }
                        }
                    },
                    book2:{
                        template:"<p>署名：react.js<end></end></p>",
                        components:{
                            end:{
                                template:"<div><button>购买</button></div>"
                            }
                        }
                    }
                }
            }
        }
    });

父组件向子组件通信   ----  props
---
    子组件不可以直接使用父组件的数据
        props 用来从父组件传递数据给子组件


    <child mess="zhs"></child>
        子组件外部传递数据 自定义mess="zhs"  数据是string类型的
    <child v-bind:mess="title" my-data=""></child>
        v-bind:mess  是将数据作为变量来处理，而不是字符串

    var child = {
        props:["mess","myData"], 指定一个传递的数据属性,用来接收传递进来的数据属性，如果属性名是驼峰命名，在外部使用的时候全小写 “-’隔开
        template:"<div><h3>{{mess}}</h3></div>"
    };
    new Vue({
        el:"#box",
        data:{
            title:"parentData"
        },
        components:{
            child:child
        }
    });

    VUE单向数据流
        props：单向数据流
            vue中父组件可以修改子组件的数据，当父组件的数据发生变化，子组件也会变化
            但是子组件无法改变父组件 ，否则就会提示警告

            需求1：将父组件的数据变为子组件的私有数据（为了解决当修改子组件的数据修改时，会有提示警告的问题？）

                父组件传递给子组件初始数据，一旦接收到数据，就会将当前得到的数据作为子组件的私有局部数据
                <input type='text' v-model='message'>
                data:function(){
                    return {message:this.mess};
                }
            需求2：一旦父组件的数据发生变化，子组件时时接受数据，即不需要存储数据，直接引用props中的属性即可
                <input type='text' v-model='mess'>

            需求3：父组件传递给子组件的数据进行处理，处理后作为局部数据，依然也可以和父组件的数据状态同步,同时不会有警告
                <input type='text' v-model='comps'>
                computed:{
                    comps:function(){
                        return this.mess.toUpperCase();//对父组件传递进来的数据进行处理
                    }
                }

props参数
-------
```
<child mess="hello"></child>
<child :mess="1"></child>
不接受外部的数据 default默认值才会生效
<child></child>
<child :mess="100"></child>
new Vue({
    el:"#box",
    data:{
        title:"哈啊"
    },
    components:{
       child:{
           template:"<div><h3>{{mess}}</h3></div>",
           props方式一：
                props:["mess"],

           props方式二：
               props:{
                   指定传递的类型，能够验证的类型：string，boolean,function,array,object,number
                   mess:Boolean,
                   mess:[Boolean,Number]    可以指定多个类型
                   mess:{   验证多项
                       type:Number,
                       type:[Number,String],    多个类型
                       type:Object,
                       default:function(){
                          return {val:"默认值"}
                          给一个对象或者数组设置默认值时，需要以函数的形式进行设置
                       }
                       default:"这是什么都没有写的情况下显示的内容", ----- 默认值
                       required:true,
                            如果为true是指当前mess是必传项，默认值与必传项是不能共同使用的
                       validator:function(val){ ----- 验证函数
                            console.log(val);
                            return val>50;
                            如果返回值为true，警告会消失，返回false会出现警告
                       }
                   }
               },

       }
    }
});
```
子组件向父组件通信   $emit
---
    监听自定义事件，在点击按钮触发自定义事件，调用父组件定义的answer函数，来接受子组件传递过来的数据
    <child v-on:getclothes="answer"></child>

    触发器 $emit 发布自定义事件
    var child = {
        template:"<div><h3>子组件</h3><input type='button' value='child说' @click='say' /><p>{{message}}</p></div>",
        data:function(){
            return {message:"准备发布"}
        },
        methods:{
            say:function(){
                this.message = "下雨啦，赶紧收衣服";
                this.$emit("getclothes",this.message); 发布$emit(自定义事件,子组件传递的消息);
                自定义事件名称不能出现大写
            }
        }
    }
    new Vue({
        el:"#box",
        data: {
            title: ""
        },
        components:{
            child
        },
        methods:{
            answer:function(val){
                console.log(val);
                this.title = val;
            }
        }
    });

子组件与子组件之间通信
---
    <h3>老大</h3>
    <prevsibling></prevsibling>
    <h4>老二</h4>
    <nextsibling></nextsibling>

    //$emit发布     $on监听
    let cpc = new Vue(); //中间人，负责传递数据
    var prevsibling = {
        template:"<div><button @click='say'>老大说</button></div>",
        methods:{
            say:function(){
                cpc.$emit("warning","我是老大，你得听我的");
            }
        }
    };
    var nextsibling = {
        mounted:function(){
            cpc.$on("warning",this.listen); //在数据挂载完成之后，开始监听
        },
        data:function(){
            return {message:"等待通知"};
        },
        template:"<div><p>接收到的通知:{{message}}</p></div>",
        methods:{
            listen:function(val){
                this.message = val;
            }
        }
    };
    new Vue({
        el:"#box",
        components:{
            prevsibling:prevsibling,
            nextsibling:nextsibling
        }
    });

slot  分发内容  分放内容  分配位置
---
    template会将child标签的内容覆盖掉，如果里面内容了，也会被覆盖掉;
    如果想要保留原有内容，可以通过<slot></slot>插入到模板相应位置中
    如果希望将模板内容放在原有布局中某一个位置，可以通过如下操作

    模板内容如下：
        <div>
           <slot name='header'></slot>
           <p>这是一个主体内容</p>
           <slot></slot>
        </div>

```
html如下：

 <child>
     <header slot="header">头部</header>
     <h3>标题</h3>
     <footer>头部</footer>
 </child>
```

# 20170523
is
---

    指定模板（组件）插入位置  需要与<component is="组件名"></component>配合使用
        <component is="users"></component>  users是字符串
        <component :is="comp"></component>  comp是变量名

        keep-alive  缓存组件状态，避免每一次切换组件重新渲染
        <keep-alive>
            <component :is="comp"></component>
        </keep-alive>

        new Vue({
            el:"#box",
            data:{
                comp:"users",
            },
            components:{
                users:{
                    template:"<div><input type='text' v-model='val'></div>",
                    data:function(){
                        return {val:"hello user"};
                    }
                },
                books:{
                    template:"<div><input type='text' v-model='val'></div>",
                    data:function(){
                        return {val:"hello books"};
                    }
                }
            }
        });

vue插件
---
    vue全家桶
        vue-cli 脚手架
        vue2
        vue-resource
        vue-router
        vuex    管理vue组件状态
        基于vue的ui

vue-resourse    请求数据
---
    全局中请求:Vue.http
    局部中请求:实例.$http

    get请求
        this.$http.get(url,{params:{key:value}).then(success,error);
            this指向当前实例
    post请求
        this.$http.post(url,{key:value}).then(success,error);
    jsonp跨域请求
        this.$http.get(url,{params:{
            key:value,
            jsonp:"cb",     cd=函数名，默认函数名是callback
            jsonpCallback:"fn"  指定函数名是什么
        }).then(success,error);
        可以自定义函数名称，与后台接口要一致
vue过渡动画
---
    animate.css 动画库
    动画名称-enter  指定进入过渡开始状态
    动画名称-enter-active   指定进入过渡激活结束状态
    动画名称-leave  指定离开过渡开始状态
    动画名称-leave-active   指定离开过渡结束状态
    使用方式：
        .name-enter{
            opacity:0;
        }
        .name-enter-active{
            transition:all 0.5s;
        }
    <transition name="动画名称">
        将需要动画的内容放在transition标签中
    </transition>

    vue中使用animate.css自定义动画
        enter-active-class后面指定animate.css中的进入动画class名称即可
        leave-active-class后面指定animate.css中的退出动画class名称即可
        <transition enter-active-class="animated hinge"  leave-active-class="animated hinge">
            <h3 v-show="flag">这是结合animate.css的自定义动画</h3>
        </transition>

vue-router  路由
---
    什么是路由？
        在一个页面中，根据切换导航展示相应内容，局部刷新，不需要跳转，重新加载整个页面
        spa 使用路由实现单页应用:所有事情都在一个页面中操作

        配置路由导航布局
            <router-link to="路由路径">导航名称</router-link>  -----  其实就是a标签
            <router-view></router-view>     路由视图

        路由创建步骤
            1,创建组件
                let 组件名称 = {
                    template:"模板内容"
                };
            2,配置路由表  路由规则   路由路径映射组件  必须是数组
                var routes = [
                    {path:"路由路径",component:组件名称},
                    {path:"*",redirect:"/index"} 重定向到存在的路径，默认显示的路由，*代表除以上路径的所有路径
                ];
            3,创建路由实例
                let VRouter = new VueRouter({
                    routes:路由规则数组名
                });
            4,在根实例中注入路由  router:将创建的路由实例赋给根实例即可
                  new Vue({
                      el:"#box",
                      router:VRouter
                  });

路由嵌套，可以通过template标签
---
    <template id="index">
        <div>
            <h3>这是首页内容</h3>
            <h3>子路由</h3>
            <nav>
                <router-link to="/index/text1">子路由1</router-link>
                <router-link to="/index/text2">子路由2</router-link>
                <router-link to="/index/text3">子路由3</router-link>
            </nav>
            缓存修改过的内容，当切换组件的时候，不会刷新页面回到最初设置的内容
            <keep-alive>
                <router-view></router-view>
            </keep-alive>

        </div>
    </template>
    1,引入模板组件,创建子路由组件
        let Index = {
            template:"#index"
        };
    2,创建路由规则
        let routes = [
            {
                path:"/index",
                component:Index,
                children:[
                    {path:"text1",component:Text1},
                    {path:"text2",component:Text2},
                    {path:"text3",component:Text3}
                ]
            },
            {path:"/news",component:News},
            {path:"/images",component:Images},
            {path:"/music",component:Music},
            {path:"*",redirect:"/index/text1"}
        ];
    3,创建路由实例
        let Vrouter = new VueRouter({
            routes:routes
        });
    4,在根实例中注入路由
        new Vue({
            el:"#box",
            router:Vrouter
        });

# 2070524
## 动态路由
    
$route
---
```
$route  获取路由信息
$route.params   路由中传递的参数
$route.query    路由中?后面的查询参数

<router-link to="/user/12">user</router-link>
<router-link to="/books/24">books</router-link>

<template id="books">
    <div>
        <h3>图书列表</h3>
        <p>当前传递的ID {{$route.params.id}}</p>
    </div>
</template>

想要拿到12或者24
需要通过$route.params对象进行获取

let routes = [
    : 指定是路由参数 id  
        被存储在$route.params:{ id: 参数 }  
        实例中使用是 this.$route.params
    {path:"/user/:id",component:User},
    {path:"/books/:id",component:Books},
];

/index/12    params{id:12}
/index/zhufeng  params{id:'zhufeng'}    $route.params.id

/index/20/zhufeng   
/index/:id/:user    params{id:20,user:zhufeng}  $route.params.id/$route.params.user
```

new VueRouter()实例
---
提供了路由操作方法
```
beforeEach与beforeRouteEnter

全局方法  ---- beforeEach

var VRouter = new VueRouter();
VRouter.beforeEach(function(to,from,next){
    console.log(to);    要到哪个路径
    console.log(from);  从哪个路径开始
    next(); 路由切换之前可以做权限验证，控制路由是否继续切换 ，控制是否继续执行，也可以传递参数

    if(to.path==="/"){
        alert("你没有用户权限");
        next({path:"/user/20/zhufeng"});    切换到指定路由
    }else{
        next();     切换到其他相应路由
    }
});

局部方法   -----  beforeRouteEnter

let User = {
    template:"#user",
    computed:{
        uid:function(){
            return this.$route.params.id;
        }
    },
    beforeRouteEnter:function(to,from,next){  相当于beforeEach，只不过是局部的
        只有切换到当前的路由之前才会触发
        console.log(to);
        console.log(from);
        alert(to.params.id);
        next({path:"/books/24/zhs"});
        next(function(vm){
            console.log(vm);  可以传递回调函数，可以将根实例作为参数传递进来使用
        });

    }
};

push    切换到指定路由

全局方法  ---- push
VRouter.push();     切换到指定路由  记录histrory管理记录

<button @click="returnback">返回到首页</button>
var vm = new Vue({
    el:"#box",
    router:VRouter,
    methods:{
        returnback:function(){
            VRouter.push("/");
        }
    }
});


局部方法 ---  push
this.$router.push('/'); 切换到指定路由
this.$router.repalce('/') 切换到指定路由 
两者展示效果一样，但是replace不会被记录到history管理记录中

<button @click="back">返回首页</button>
methods:{
    back:function(){
        this.$router.push('/');
    }
}

go  控制页面前进后退   window.history.go

全局方法
VRouter.go(-1);  

局部方法
this.$router.go("整数"); 控制页面前进后退 
    大于1，前进到上一个页面  小于1 后退到上一个页面
```

## 动态绑定路由方法

```
<router-link :to="indexRoute">首页</router-link>
new Vue({
    el:"#box",
    router:VRouter,
    data:{
        indexRoute:{path:'/index/20',query:{name:'zhs'}}
    }
});
```

## 命名路由

```
<!--命名路由  name代表相应的路径-->
<router-link :to="{name:'index', params:{uid:24},query:{user:'zhs'}}">首页</router-link>
<router-link :to="{name:'video', params:{uid:40},query:{user:'tl'}}">视频</router-link>
<router-view></router-view>

<!--路由规则设置-->
let routes = [
    {path:"/index/:uid",name:"index",component:Index},
    {path:"/video/:uid",name:"video",component:Video}
];
```

## 监听路由

```
new Vue({
    el:"#box",
    router:VRouter,
    watch:{
        "$route":function(to,from){  //监听路由   监听路由信息
            console.log(arguments);
            console.log(this);
        }
    }
});
```

## vue 单文件组件

    自定义的后缀是.vue文件，一个文件就是一个组件，(包含功能，结构，样式，数据状态...)

    如果想使用vue单文件组件，需要借助编译工具  webpack browserify编译成可以识别的

### 后缀为.vue文件书写规范

```
第一部分：
<template>
    <div id="box">
        <h3 @click="say">{{title}}</h3>
    </div>
</template>
第二部分：
<script>
    export default{
        data(){
            return {title:"今天星期四"};
        },
        methods:{
            say:function(){
                alert(1);
            }
        }
    }
</script>
第三部分：
<style>
    h3{
        color:#ccc;
    }
</style>
```

### 如何使用单文件组件？
- 导入vue模块
- 在main.js中导入.vue单文件组件
- import 给.vue文件的名称 from ".vue文件路径"
- 声明一个Vue实例
- 在实例中注册组件

```
import Vue from 'vue'  
import App from './App.vue' 

new Vue({
  el: '#app',
  components:{ 
      App,
      Hello,
      Zhs
  }
});
```

## vue-cli  
- vue脚手架：将基本的环境搭建好，然后我们基于这个环境开发
- 安装vue-cli  
```
npm install vue-cli -g
vue list    查看模板参数
vue init <template-name> <project-name>   初始化vue项目
    eg:vue init webpack-simple(依赖的模板) myvue(项目名称)
    模板类型
        browserify
        browserify-simple
        pwa
        simple 
        webpack 
        webpack-simple 

运行项目

cd myvue    进入项目目录
npm install 安装依赖文件
npm run dev 开启server
```

# 20170525
## webpack   构建工具
### 安装webpack  
- 全局安装  可以在cmd中使用  默认支持node模块化
```
nmp install webpack -g 
```
- 项目依赖中安装webpack
```
npm install webpack --save-dev/-D    开发依赖
```
- 在当前目录下创建webpack配置文件 --- 
```
webpack.config.js   默认名
```

### 开发环境部署
- 安装webpack-dev-server
```
npm install webpack-dev-server -g   基于express
```
- 项目中安装依赖
```
npm install webpack-dev-server --save-dev
```
- 在项目根目录创建index.html
- 引入编译后的文件
- 命令窗口运行webpack-dev-server
```
webpack-dev-server 回车即可
```
- 开发调试结束后,cmd中输入命令，生成dist目录
```
webpack 
```

## package.json 指定运行脚本
```
"scripts": {
    //通过webpack-dev-server自动打开默认浏览器，时时监控外部文件的变化
    "dev":"webpack-dev-server --open --hot" ,  ---- 开发阶段  npm run dev
    "build":"webpack --progress --hide-modules"  ---- 生产阶段 npm run build
},
```

## 手动指定配置文件
- 默认会自动找webpack.config.js,但是如果有多个配置文件，可以手动指定
- webpack-dev-server --config  webpack.config1.js
- 可以将手动指定配置文件的代码写入package.json中
```
{
  "name": "web",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev":"webpack-dev-server --config webpack.config1.js --open --hot",
    "build":"webpack --progress --hide-modules"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^2.6.0",
    "webpack-dev-server": "^2.4.5"
  }
}
```


### webpack.config.js分析
- __dirname是指当前文件所在目录的绝对路径
- __filename是指当前文件的绝对路径
- path.resolve(__dirname,"./dist");   路径模块,将编译后的文件接解析出绝对路径
- path.join(__dirname,"./dist");    路径模块,将解析出来的绝对路径与dist文件拼接在一起
- 配置文件完成后，在当前目录下打开cmd，输入webpack进行编译
```
let path = require("path"); //node中操作路径模块，可以拼接，可以解析
//需要导出的配置对象
module.exports = {
    //需要编译的文件入口
    entry:"./src/index.js",
    //编译后的文件输出出口
    output:{
        //指定编译后的输出路径(绝对路径)
        path: path.resolve(__dirname,"./dist"),
        //指定编译后的文件名  "[name].js"-->默认编译后是main.js
        filename:"bundle.js",
        //手动指定server资源输出后的存放路径,不写默认是根路径/
        publicPath:"/dist/" 
    }
};
```

## ES6导入导出
```
- ES6导出

导出1：
export {
    say
}
导出2:
export default{
    say
}

- ES6导入 

导入1：
import {say} from "./public/b.js"
如果导入的函数名称与当前页面的函数重名，可以按照以下方法书写
    import {say as 别名} from "./public/b.js"
导入2：
import 自定义名（Hello） from "./public/b.js"


```

- 解析ES6写法的代码  babel加载器
```
npm install babel-core babel-loader -D
```

- 新建.babelrc文件，让babel来处理解析ES6，文件中需要es2015   (将es6写法转换为es5)
```
npm install babel-preset-es2015 -D
```
## Vue引入问题
- 通过npm install导入的vue文件，模块化默认导入的是运行时构建文件，没有模板编译功能，会报错
- 解决方法1：通过rander函数
- 解决方法2：在webpack配置文件中添加以下代码，会将默认导入的文件指向新文件
```
resolve: {
  alias: {
    'vue$': 'vue/dist/vue.common.js'
  }
}
```
- 解决办法3：导入时找需要的路径，但不推荐

## webpack解析vue单文件组件
```
npm i vue-loader -D     指定vue加载器,为了让webpack编译解析vue单文件组件
npm i vue-template-compiler -D  
```


# 20170531

## webpack

```
webpack 
-w   实时监听编译，但是不会自动更新页面
--progress  显示进程
--hide-modules  隐藏模块信息
```

## webpack-dev-server
```
webpack-dev-server --progress --open --port 8090 
--progress          显示编译进程
--open              自动打开浏览器预览
--port 8090         自定义端口好，默认是8080
--hot               热替换
```

## ES6问题
- 1，借助babel进行转码   将es6转换为es5
```
npm install babel-core babel-loader -D
```

- 2，准备es2015插件  预设插件包
```
npm install babel-preset-es2015 -D
```
- 3，准备.babelrc文件,文件内容如下
```
{
  "presets":["es2015"]
}
```
- 4，在webpack配置文件中设置需要通过哪些加载器来匹配文件 webpack.config.js

```
module.exports = {
    entry:{
        main:"./src/index.js"
    },
    output:{
        path:path.resolve(__dirname,"./dist"),
        publicPath:"/dist/",
        filename:"[name].js"
    },
    module:{//加载规则配置
        rules:[
            {
                //将es6转化成es5
                test:/\.js$/,//匹配的文件
                loader:"babel-loader",//通过什么加载器进行匹配
                exclude:"/node_modules/" //排除哪些文件
            }
        ]
    }
};
```
- 5，指定草案阶段
```
npm install babel-preset-stage-0 -D
```
- 6，配置.babelrc
```
"presets":["es2015","stage-0"]
```


## source map
- 除错工具直接显示原文件代码，不会显示编译后的代码,生成一个sourcemap文件，存储编译前代码位置信息，便于在原文件中调试
```
devtool:"#eval-source-map" //记录编译之前的代码对应位置
```

## vue包引用问题
- 默认 NPM 包导出的是 运行时 构建。为了使用独立构建，在 webpack 配置中添加下面的别名
```
resolve: {
  alias: {
    'vue$': 'vue/dist/vue.common.js'
  }
}
```

## .vue单文件组件使用问题 
- 处理vue单文件组件需要借助 vue-loader  
```
npm install vue-loader -D
```
- 在webpack配置文件中配置一下规则
```
{
    test:/\.vue$/,//匹配所有vue单文件组件
    loader:"vue-loader" //通过什么加载器进行匹配
}
```

## vue模板编译问题
- vue-loader 依赖的vue模板编译模块
```
npm install vue-template-compiler -D
```

## css渲染问题
- 先依赖css-loader，其次需要将css样式内嵌在标签中 style-loader
```
npm install css-loader -D
npm install style-loader -D
```
- 在webpack中配置规则
```
{
    test:/\.css$/,
    loader:"style-loader!css-loader"//先处理后面的加载器，再处理前面的
    //style-loader 将css样式内嵌在html页面中
    //多个loader中间用！隔开，或者用数组
    //loader:["style-loader","css-loader"]
}
```

## 使用less写css样式问题
- 安装less与less加载器
```
npm install less less-loader -D
```
- 在webpack中配置规则  既可以控制外部less文件，有可以控制.vue单文件组件中的less规范的css样式
```
{
    test:/\.less$/,
    loader:"style-loader!css-loader!less-loader"
}
```

## 加载图片问题
- 安装file-loader或者url-loader   url-loader可以将图片转换为base64格式的
```
npm install file-loader -D 或
npm install url-loader -D
```
- 在webpack中配置规则
```
{
    test:/\.(jpe?g|png|gif|svg)$/,
    loader:"file-loader"
}
```
- 或
```
{
    test:/\.(jpe?g|png|gif|svg)$/,
    loader:"url-loader",
    options:{
        limit:10000, //限制图片,10kb以下，进行base64编码，否则正常显示
        name:"[name].[ext]?[hash]" //重写文件名
    }
}
```

## 使用bootstrap ui组件问题
- 安装bootstrap
```
npm install bootstrap -S
```
- 在index.js中导入bootstrap
- 在webpack中修改默认指定文件  地址指向css文件
```
resolve:{
    alias:{
        "vue$":"vue/dist/vue.common.js",   //导入独立构建文件
        "bootstrap$":"bootstrap/dist/css/bootstrap.css"
    }
}
```

- 报错eot woff2 woff ttf字体图标找不到
```
{
    test:/\.(jpe?g|png|gif|svg|eot|woff2|woff|ttf)$/,
    loader:"url-loader",
    options:{
        limit:10000, //限制图片,10kb以下，进行base64编码，否则正常显示
        name:"[name].[ext]?[hash]" //重写文件名
    }
}
```

## 完整的filename格式问题 [name].[hash].js   
- webpack.config.js hash值是随机的，为了防止缓存 ,但是文件名称只要改变，index.html中路径就要修改
```
output:{
    path:path.resolve(__dirname,"./dist"),
    publicPath:"/dist/",
    //filename:"[name].js"
    filename:"[name].[hash].js" //添加hash值，值是随机的,为了避免缓存
}
```
- webpack.config.js 需要借助webpack插件 html-webpack-plugin
```
let HtmlWebpackPlugin = require("html-webpack-plugin");//自动生成html文件，针对单入口文件

plugins:[ //webpack plugin
    new HtmlWebpackPlugin({
        title:"hello zhs",  //生成的html页面title
        favicon:'./src/assets/logo.png',    //生成页卡图标
        template:"./index.html",     //指定html模板
        chunks:["main"], //指定依赖的js模块
        inject:"head"  //将依赖的文件存放位置,放在head标签里，默认是存放在body中
    })
]
```


## 公共模块问题(将使用率较高的模块提取出来，只打包一次)
- 依赖第三方模块 webpack.config.js
```
let webpack = require("webpack");

```
- webpack.config.js 配置插件参数
```
plugins:[ //webpack plugin
    new HtmlWebpackPlugin({
        title:"hello zhs", //生成的html页面title
        favicon:'./src/assets/logo.png', //生成页卡图标
        template:"./index.html", //指定html模板
        //chunks:["main"], //指定依赖 -- 单文件入口，默认名称main
        chunks:["common","chunk1","chunk2"]   //-- 多文件入口 ,添加入口名称即可
        //inject:"head"  //将依赖的文件存放位置,放在head标签里，默认是存放在body中
    }),
    new webpack.optimize.CommonsChunkPlugin("common") //用来提取多入口中的公共模块
    //如果common文件是动态生成的，需要在chunks中将common放在最前面，否则会报错
    //如果不是动态生成的，就直接在html页面引入即可 <script src="common.js"></script>
]
```

## css样式单独打包问题  -- 可以将外部css样式与less外部文件打包到一个文件，单文件组件的样式无法打包
- 依赖第三方模块
```
npm i extract-text-webpack-plugin -D
```

- webpack.config.js 导入第三方模块
```
let ExtractTextPlugin = require("extract-text-webpack-plugin");//将css单独打包
```

- webpack.config.js 修改loader加载器中配置
```
{
    test:/\.css$/,
    loader:ExtractTextPlugin.extract({use:"css-loader"})
},
{
    test:/\.less$/,
    loader:ExtractTextPlugin.extract({use:"css-loader!less-loader"})
}
```
- webpack.config.js 在plugin中
```
new ExtractTextPlugin("index.css") //指定一下打包之后的文件名称
```

## 文件压缩问题 - 通常是生产后使用
- 在配置文件中，plugin中 将js文件压缩 webpack核心模块提供的压缩方法
```
new webpack.optimize.UglifyJsPlugin({ 
    sourceMap:true, //保留代码压缩编译前的位置
    compress:{
        warnings:false  //删除调试语句
    }
}) 
```

## 区分开发环境问题
- 安装cross-env
```
npm install cross-env -D
```
- package.json修改
```
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "cross-env NODE_ENV=development webpack-dev-server --open --hot",
    "build": "cross-env NODE_ENV=production webpack --progress --hide-modules"
}
```
- webpack.config.js配置判断环境，进行压缩文件
```
if(process.env.NODE_ENV==="production"){//生产环境下
    console.log("this is production!!!");
    module.exports.plugins = (module.exports.plugins||[]).concat([
        new webpack.optimize.UglifyJsPlugin({
            sourceMap:true, //保留代码压缩编译前的位置
            compress:{
                warnings:false  //删除调试语句
            }})
    ]);
}else{
    console.log("this is development!!!");
}
```

## 省略扩展名问题
- 配置文件添加
```
resolve:{
    alias:{
        "vue$":"vue/dist/vue.common.js", 
        "bootstrap$":"bootstrap/dist/css/bootstrap.css"
    },
    extensions:[".js",".css",".vue",".less"]//将文件后缀名称放进数组中
}
```
- 可以将导入的文件的后缀名去掉
```
import Vue from "vue"
import Hello from "./components/hello"
import "./public/index"
import "./public/hello"
```

## webpack.config.js 20170531完整版
```
let path = require("path");
let webpack = require("webpack");
let HtmlWebpackPlugin = require("html-webpack-plugin");//自动生成html文件，针对单入口文件
let ExtractTextPlugin = require("extract-text-webpack-plugin");//将css单独打包

module.exports = {
    //entry:"./src/index.js",
    entry:{
        chunk1:"./src/index.js",
        chunk2:"./src/main2.js"
    },
    output:{
        path:path.resolve(__dirname,"./dist"),
        // publicPath:"/dist/",
        //filename:"[name].js"
        filename:"[name].[hash].js" //添加hash值，值是随机的,为了避免缓存
    },
    module:{//加载规则配置
        rules:[
            //将es6转化成es5
            {
                test:/\.js$/,//匹配所有js文件
                loader:"babel-loader",//通过什么加载器进行匹配
                exclude:"/node_modules/" //排除哪些文件
            },
            {
                test:/\.vue$/,//匹配所有vue单文件组件
                loader:"vue-loader" //通过什么加载器进行匹配
            },
            // {
            //     test:/\.css$/,
            //     loader:"style-loader!css-loader"//先处理后面的加载器，再处理前面的
            //     //style-loader 将css样式内嵌在html页面中
            //     //多个loader中间用！隔开，或者用数组
            //     //loader:["style-loader","css-loader"]
            // },
            {
                test:/\.css$/,
                loader:ExtractTextPlugin.extract({use:"css-loader"})
            },
            // {
            //     test:/\.less$/,
            //     loader:"style-loader!css-loader!less-loader"
            // },
            {
                test:/\.less$/,
                loader:ExtractTextPlugin.extract({use:"css-loader!less-loader"})
            },
            {
                test:/\.(jpe?g|png|gif|svg|eot|woff2|woff|ttf)$/,
                loader:"url-loader",
                options:{
                    limit:10000, //限制图片,10kb以下，进行base64编码，否则正常显示
                    name:"[name].[ext]?[hash]" //重写文件名
                }
            }
        ]
    },
    //生成一个sourcemap文件，存储编译前代码位置信息，便于在原文件中调试
    devtool:"#eval-source-map", //记录编译之前的代码对应位置
    //默认 NPM 包导出的是 运行时 构建。为了使用独立构建，在 webpack 配置中添加下面的别名
    resolve:{
        alias:{
            "vue$":"vue/dist/vue.common.js",   //导入独立构建文件
            "bootstrap$":"bootstrap/dist/css/bootstrap.css"
        },
        extensions:[".js",".css",".vue",".less"]//将文件后缀名称放进数组中
    },
    //配置devServer
    devServer:{
        noInfo:true, // 隐藏编译信息
        //hot:true// 热替换可以在配置文件中设置，但是需要配合 new webpack.HotModuleReplacementPlugin()使用
    },
    plugins:[ //webpack plugin
        new HtmlWebpackPlugin({
            title:"hello zhs", //生成的html页面title
            favicon:'./src/assets/logo.png', //生成页卡图标
            template:"./index.html", //指定html模板
            //chunks:["main"], //指定依赖 -- 单文件入口，默认名称main
            //chunks:["chunk1","chunk2"],  -- 非动态生成的common文件
            chunks:["common","chunk1","chunk2"]   //-- 多文件入口 ,添加入口名称即可
            //inject:"head"  //将依赖的文件存放位置,放在head标签里，默认是存放在body中
        }),
        new webpack.optimize.CommonsChunkPlugin("common"), //用来提取多入口中的公共模块
        //如果common文件是动态生成的，需要在chunks中将common放在最前面，否则会报错
        //如果不是动态生成的，就直接在html页面引入即可 <script src="common.js"></script>
        new ExtractTextPlugin("index.css"), //将css单独打包，指定一下打包之后的文件名称
        // new webpack.optimize.UglifyJsPlugin({
        //     sourceMap:true, //保留代码压缩编译前的位置
        //     compress:{
        //         warnings:false  //删除调试语句
        //     }
        // }) //将js文件压缩 webpack核心模块提供的压缩方法
    ]
};
if(process.env.NODE_ENV==="production"){//生产环境下
    console.log("this is production!!!");
    module.exports.plugins = (module.exports.plugins||[]).concat([
        new webpack.optimize.UglifyJsPlugin({
            sourceMap:true, //保留代码压缩编译前的位置
            compress:{
                warnings:false  //删除调试语句
            }})
    ]);
}else{
    console.log("this is development!!!");
}
```

# 20170601
## vuex 状态管理库，用来管理大型组件应用中的共享数据

### 安装vuex
```
npm install vuex -S
```

### 在src中单独创建一个store.js
- 导入依赖模块
```
import Vue from "vue"
import Vuex from "vuex"

Vue.use(Vuex);
```
- 生成Vuex.Store的实例
```
export default new Vuex.Store({
    state:{

    },
    getters:{

    },
    mutations:{

    },
    actions:{

    }
});
```

### 获取vuex共享状态
> 前提是注册到根组件 store
- 1，直接获取
```
{{$store.state...}}
```
- 2，计算属性
```
computed:{
    count(){
        return this.$store.state.count;
    },
    say(){
        return this.$store.state.say;
    }
}
```
- 3，借助辅助函数
```
导入mapState
    import {mapState} from "vuex" //借助辅助函数
计算属性配置
    computed:{
        ...mapState(["count","say"])//需要配置.babelrc文件  前提安装babel-preset-stage-0
    }
.babelrc
    {
      "presets": [
          ["env", { "modules": false }],
          "stage-0"
      ]
    }
使用
    <p>{{count}}</p>
    <p>{{say}}</p>
```

### 改变state状态
- 1，直接改变state
```
<button @click="$store.state.count++">改变state状态</button>
```
- 2,mutations改变state状态
> $store.commit("函数名称",传递参数); es6设置默认参数 n =2
```
<button @click="$store.commit('modState')">改变state状态</button>
mutations:{
    modState(state){
        state.count+=20;
    }
}
```
- 3，借助辅助函数来传递mutations 修改state状态
```
使用
<button @click="modState">改变state状态</button>
导入
import {mapState,mapMutations} from "vuex"
通过方法将store.js中的mutations中定义的函数传递过来
methods:{
    ...mapMutations(['modState'])
}
```
- 4，actions通过dispatch方法与commit方法来修改state状态
> context对象包含 commit方法 dispatch方法
```
<button @click="$store.dispatch('aMode')">改变state状态</button>
mutations:{
    modState(state){
        state.count+=20;
    }
},
actions:{
    aMode(context){
        context.commit("modState");  提交到mutations，发布modState事件
    }
}
```
> 当需要发布的事件较多时，采用结构赋值的形式
```
mutations:{
    modState(state){
        state.count+=20;
    },
    subState(state){
        state.count+=20;
    }
},
actions:{
    aMode({commit}){//context对象包含 commit方法 dispatch方法
        commit("modState");
        commit("subState");
    }
}
```
> 借助辅助函数mapAction方法来修改state状态
```
import {mapState,mapMutations,mapActions} from "vuex"
<button @click="aMode">改变state状态</button>
```

### getters的用途，store的计算属性  通过旧值进行计算得到新值
- 直接得到
```
<h3>得到getters计算后的值:{{$store.getters.newCount}}</h3>
getters:{//store的计算属性,如何得到计算过的属性
    newCount(state){
        return state.count+20;
    }
},
```
- 通过辅助函数mapGetters
```
import {mapState,mapMutations,mapActions,mapGetters} from "vuex"
<h3>通过辅助函数mapGetters得到getters计算后的值:{{newCount()}}</h3>
methods:{
    ...mapMutations(['modState']),
    ...mapActions(['aMode']),
    ...mapGetters(['newCount'])
}
```

### store.js
```
import Vue from "vue"
import Vuex from "vuex"
Vue.use(Vuex);  //初始化状态库
export default new Vuex.Store({
    state:{     //数据状态
        count:1,
        say:"hello vuex"
    },
    getters:{   //store的计算属性
        newCount(state){
            return state.count+20;
        }
    },
    mutations:{
        modState(state){
            state.count+=20;
        }
    },
    actions:{
        aMode(context){//context对象包含 commit方法 dispatch方法
            context.commit("modState");
            context.commit("subState");
        }
    }
});
```

## 辅助函数
- mapState      获取state里面的状态
- mapMutations  同步修改state状态 commit  mutations
- mapActions    可以异步修改state状态  dispatch - commit
- mapGetters    计算出来新的数据属性(依赖于state)

### 辅助函数版
- 1,main.js  注册根组件
```
import Vue from 'vue'
import {Index,Hello} from "./components"
import store from "./store"

new Vue({
    el: '#app',
    components:{
        Index,
        Hello
    },
    store:store
});
```
- 2,vue单文件组件
```
<template>
    <div id="hello">
        <h1>{{title}}</h1>
        <h2>mapState:{{count}}</h2>
        <h3>mapGetters:{{countGetter}}</h3>
        <button @click="modState(10)">mapMutations</button>
        <button @click="aMode">mapActions</button>
    </div>
</template>
<script>
    import {mapState,mapGetters,mapMutations,mapActions} from "vuex"
    export default{
        name:"hello",
        data(){
            return {title:"hello hello!"}
        },
        computed:{
            ...mapGetters(["countGetter"]),
            ...mapState(["count"])
        },
        methods:{
            ...mapMutations(["modState"]),
            ...mapActions(['aMode'])
        }
    }
</script>
```
- 3,store.js  数据状态
```
import Vue from "vue"
import Vuex from "vuex"
Vue.use(Vuex);
export default new Vuex.Store({
    state:{  //驱动应用的数据源
        count:10
    },
    getters:{  //store的计算属性
        countGetter(state){
            return state.count + 20;
        }
    },
    mutations:{  //响应state
        modState(state,n=2){
            state.count+=n;
        }
    },
    actions:{   //派发mutations
        aMode({commit}){
            commit('modState');
        }
    }
});
```

## 设置dev-server代理
- 在webpack.config.js中设置 devserver
```
devServer: {
    historyApiFallback: true,//请求一个不存在的页面返回首页  解决404响应
    noInfo: true,
    proxy:{

        1,url总需需要携带 /api才可以使用
        //"/api":"http://127.0.0.1:9090"
        2,避免携带 /api
        "/api":{
            target:"http://127.0.0.1:9090", //http://localhost:8080/api
            pathRewrite:{'^/api':''} //重写路径，将有/api的路径清空/api
        }
    }
  },
```

# 20170606
## REACT
### react安装
- create-react-app是你开始构建一个全新单页应用的最好方式
```
npm install -g create-react-app(装一次即可)
create-react-app my-app

cd my-app
npm start
```
### JSX
- JSX是一种JS和HTML混合的语法,将组件的结构、数据甚至样式都聚合在一起定义组件,会编译成普通的Javascript。
1. 遇到HTML标签(以 < 开头)，就用HTML规则解析
2. 遇到代码块(以 { 开头)，就用JavaScript规则解析
3. 使用样式时可以让style等于一个样式对象
4. 使用样式类时只能使用className=类名,因为class是Javascript关键字
```
var persons = ['阿米尔汗', '范冰冰', '郭跃'];
var style = {color:'red'};
ReactDOM.render(
  <div>
  {
    persons.map(function (person) {
      return <div style={style}>Hello, {person}!</div>
    })
  }
  </div>,
  document.getElementById('app')
);
```

### 组件
- 我们可以很直观的将一个复杂的页面分割成若干个独立组件,每个组件包含自己的逻辑和样式,再将这些独立组件组合完成一个复杂的页面。 这样既减少了逻辑复杂度，又实现了代码的重用
1. 可组合：一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部
2. 可重用：每个组件都是具有独立功能的，它可以被使用在多个场景中
3. 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护
- React允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件
- 组件类的第一个字母必须大写 组件类能且只能包含一个顶层标签
```
import React from 'react';
class Message extends React.Component{
    render: function() {
        return <h1>Hello</h1>;
    }
});
ReactDOM.render(
    <Message/>,
    document.getElementById('app')
);
```

### 属性
- 每个组件可以有自己的属性,一般用来存放组件初始后不变的数据,比如人的性别，姓名等属性一般用作组件的数据源，一般由父组件传入,比如你的名字一般是由你父母取的 属性可以通过this.props中取出
1. propTypes可以用来定义传入组件属性的名称和类型
2. getDefaultProps函数可以用来定会引起组件的默认属性 
```
import React from 'react'; 
class Message extends React.Component{ render: function() {
  return (<h1> {this.props.name}</h1>);
} });
```
```
Person.propTypes = { name: PropTypes.string.isRequired }; 
Person.defaultProps = { name: '无名' }; 
let props = {name:'张三'}; 
ReactDOM.render( ,//属性可以在使用组件时传入 document.getElementById('app') );
```

### this.props.children
- this.props对象的属性与组件实例的属性一一对应,但this.props.children属性表示组件的所有子节点 
- React.Children.map是一个工具方法，用于实现对数组元素的映射
```
class Message extends React.Component{
    render: function() {
      return (
            <ol>
                {
                    React.Children.map(this.props.children,
                      function (child) {
                        return <li>{child}</li>;
                    })
                }
            </ol>
      );
    }
});

ReactDOM.render(
    <Person>
        <span>大毛</span>
        <span>二毛</span>
        <span>三毛</span>
    </Person>,
    document.getElementById('app')
);
```

### 状态和事件处理
- 组件的状态就像人的心情，会经常变化，而且只能由自己来改变
- 组件一开始有一个初始状态,然后用户互动,导致状态变化，从而触发界面重新渲染
- 可以给按钮绑定事件，当事件发生的时候调用对应的方法改变组件的状态
```
import React from 'react';
import ReactDOM from 'react-dom';
class Person extends React.Component{
  constructor(props){
      super(props);
      this.state = {happy:true};
  }
  changeHappy = ()=>{
      this.setState({
          happy: !this.state.happy
      })
  }
  render(){
      return (
          <div>
              <p>姓名:{this.props.name} {this.state.happy?'开心':'伤心'}</p>
              <button onClick={this.changeHappy}>改变</button>

          </div>
      )
  }
}
Person.defaultProps = {
  name:'无名氏'
}
Person.propTypes = {
  name:React.PropTypes.string.isRequired
}
let props = {age:8,name:9};
ReactDOM.render(<Person {...props}/>,document.getElementById('root'));
```

### 表单元素双向数据绑定
> 注意: 如果给表单元素设置了value属性，则必须指定onChange事件处理函数，否则 此字段会变成只读状态
```
class Input extends React.Component{
     constructor(props){
          super(props);
          this.state = {value: '珠峰培训'};
        }
    handleChange: function(event) { //处理改变事件
        this.setState({value: event.target.value});
    },
    render: function () {
        var value = this.state.value;
        return (
            <div>
                <input style={{color:'red'}} type="text"
                value={value} onChange={this.handleChange} />
                <p>{value}</p>
            </div>
        );
    }
});

ReactDOM.render(<Input/>, document.getElementById('app'));
```

### 复合组件
- 多个简单的组件嵌套，可构成一个复杂的复合组件，从而完成复杂的交互逻辑
```
class Panel extends React.Component{
    render: function () {
        return (
            <div className="panel panel-default">
                <PanelHead head={this.props.head}/>
                <PanelBody body={this.props.body}/>
            </div>
        );
    }
});


class PanelHead extends React.Component{
    render: function () {
        return (
            <div className="panel-heading">
                {this.props.head}
            </div>
        );
    }
});


class PanelBody extends React.Component{
    render: function () {
        return (
            <div className="panel-body">
                {this.props.body}
            </div>
        );
    }
});

ReactDOM.render(
    <Panel
        head="头部"
        body="正文"
    />,
    document.getElementById('app')
);
```

### DOM操作
- 给组件加上ref="xxx"后，可在父组件中通过this.refs.xxx获取该DOM元素
```
import React from 'react';
//每个表单元素的值是受组件状态的控制
// 10 8 16
// 10
export default class Calculator extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            numA:0,
            op:'+',
            numB:0
        }
    }
    changeA(event){
        this.setState({
            numA:event.target.value
        });
    }
    changeOp(event){
        this.setState({
            op:event.target.value
        });
    }
    changeB(event){
        this.setState({
            numB:event.target.value
        });
        console.log(this.state.numA+this.state.op+this.state.numB);
    }
//warning.js:36Warning: Failed form propType: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field.
    render(){
        return (
            <div>
                <input onChange={this.changeA.bind(this)} type="text" value={this.state.numA}/>
                <input onChange={this.changeOp.bind(this)}  type="text" value={this.state.op}/>
                <input onChange={this.changeB.bind(this)}  type="text" value={this.state.numB}/>
                <span>{eval(this.state.numA+this.state.op+this.state.numB)}</span>
            </div>
        )
    }
}
```

### 组件的生命周期
- React中可以指定在组件的生命周期的不同阶段执行的函数
1. 挂载前      componentWillMount(){}
2. 挂载中      render(){}
3. 挂载完成    componentDidMount(){}
4. 组件是否需要更新 shouldComponentUpdate();
5. 组件将要更新 componentWillUpdate
6. 组件更新完成 componentDidUpdate
7. 组件接受到新的属性 componentWillReceiveProps
8. 组件将要被删除      componentWillUnmount
> 执行顺序：父组件加载前 子组件加载前 子组件加载后 父组件加载后 父组件将要卸载 子组件将要卸载
```
import React from 'react';
import ReactDOM from 'react-dom'
/**
 * 1.实例化组件类，并调用它的render方法得到虚拟DOM元素
 * 2.React将要把此虚拟DOM元素挂载到页面中
 */
export default class Counter extends React.Component {
    constructor(props){
        super(props);
        this.state = {number:0};
    }
    componentWillMount(){
        console.log('1. componentWillMount 组件将要被挂载')
    }
    componentDidMount(){
        console.log('3. componentDidMount 组件挂载结束')
    }
    handleClick=() =>{
        this.setState({number:this.state.number+1});
    }
    //组件是否应该更新
    shouldComponentUpdate(newProps,newState){
        console.log('4. shouldComponentUpdate 组件是否要被更新')
       if(newState.number%2==0){
           return true;
       }else{
           return false;//如果返回false render方法将不再执行
       }
    }
    componentWillUpdate(){
        console.log('5. componentWillUpdate 组件将要更新')
    }
    componentDidUpdate(){
        console.log('6. componentWillUpdate 组件更新完成')
    }
    componentWillUnMount(){
        console.log('7. componentWillUnMount 组件将要被卸载')
    }
    render() {
        console.log('2. render 渲染')
        return (
            <div>
                <button onClick={this.handleClick} className="btn btn-primary">
           父计数器 <span className="badge">{this.state.number}</span>
                </button>
            </div>
        )
    }
}
```

# 20170613
## gulp + react-router-4
- gulp使用流程
1. npm install -g gulp   全局安装（安装一次即可）
2. 创建gulpfile.js文件
3. 初始化package.json文件
4. npm install gulp -S   本地安装 
5. 安装npm install gulp-less gulp-concat gulp-uglify gulp-rename gulp-clean-css gulp-minify-html gulp-inject gulp-babel gulp-plumber gulp-connect  --save-dev

- gulp方法
1. gulp.task("任务名"，执行函数);  定义任务
2. gulp.src("文件相对路径");  用来获取可读流
3. gulp.dest("相对路径")  获取一个可写流   参数为目录名
4. gulp.watch("文件相对路径",回调函数); 监控src目录下所有的html文件的变化，当他们变化之后执行对应的回调函数

## gulp插件
> gulp插件特点:导出的都是函数，需要调用来使用，调用的目的是为了传递参数
- 合并js文件插件
```
let concat = require("gulp-concat");
gulp.src("./src/js/*.js").pipe(concat("all.js"));
```
- 压缩js文件插件
```
let uglify = require("gulp-uglify");
gulp.src("./src/js/*.js").pipe(concat("all.js")).pipe(gulp.dest("./build/js")).pipe(uglify());
```
- 重命名插件 
```
let rename = require("gulp-rename");
gulp.src("./src/js/*.js").pipe(concat("all.js")).pipe(gulp.dest("./build/js")).pipe(uglify()).pipe(rename("all.min.js")).pipe(gulp.dest("./build/js"));
pipe($.rename(function (obj) {
    obj.basename+=".min";//可以自动修改压缩文件名称
}))
```
- 将es6语法转成es5  ---  配置.babelrc文件   安装npm install babel-preset-es2015
```
let babel = require("gulp-babel");
gulp.src("./src/js/*.js").pipe(babel());
```
- 编译less文件
```
let less = require("gulp-less");
gulp.src("./src/less/*.less").pipe($.less());
```
- 压缩css文件
```
gulp.src("./src/less/*.less").pipe($.less()).pipe($.cleanCss());
```
- 压缩html插件
```
let minifyHtml = require("gulp-minify-html");
gulp.src("./src/*.html").pipe(minifyHtml()).pipe(gulp.dest("./build"));
```
- 启动服务器插件  启动一个http服务器预览项目，并且当源码修改后自动刷新浏览器
```
let connect = require("gulp-connect");
connect.server({
    port:8080, //端口号
    root:"./build"  //静态文件根目录
});
```

- 直接加载所有的gulp插件  -- npm install gulp-load-plugins -S  
```
let $ = require("gulp-load-plugins")();
gulp.task("css",function () {
    gulp.src("./src/less/*.less")
        .pipe($.less())
        .pipe($.concat("all.css"))
        .pipe(gulp.dest("./build/css"))
        .pipe($.cleanCss())
        .pipe($.rename(function (obj) {
            obj.basename+=".min";
        }))
        .pipe(gulp.dest("./build/css"));
});
```
> * 匹配任意字符，除了路径分隔符      "./src/js/*.js"
> ** 可以匹配任意字符，包括路径分隔符   "./src/**/*.js"
> 注意：插件不支持es6语法
