# 20170510
## 模块
内置模块
---
    http模块
        html.createServer(function(req,res){
            req 代表客户端
                req.url  请求路径
                req.method  获取提交方式

            res 代表服务端
                res.end(); 结束响应并可以返回一些信息回送给客户端（类型只能为字符串与buffer）
                res.setHeader("Content-Type","text/html;charset=utf-8");设置返回给客户端的界面信息
                res.statusCode    修改状态码
                res.setHeader("Access-Control-Allow-Origin","*");
                以上方式可以解决跨域访问接口，但需要后台配合，可以在server中设置可以访问的域名
                在服务端没有../
        }).listen(端口,function(){
            监听端口
        });

    url模块
        url.parse(地址,true);    解析url，第二个参数为true，可以将query解析成key:value形式
    fs模块 ----  文件系统
        fs.readFileSync("文件路径",设置编码格式);  同步方式读取文件内容，默认是buffer
        fs.readFile("文件路径",设置编码格式,function(err,data){
            if(err){
                console.log(err);
            }else{
                console.log(data);
            }
        }); 异步方式读取文件内容
        fs.exist("文件地址"); 根据路径异步判断文件是否存在  ，返回布尔类型
        fs.existsSync("./1.html");根据路径同步判断文件是否存在  ，返回布尔类型
        fs.writeHead(状态码,{location:"地址"});  重定向
     path模块
        path.resolve("./a.js"); 获取当前文件的绝对路径
第三方模块
---
    mime模块
        mime.lookup();  解析出指定文件的mine类型
自定义模块
---
    导入
        let server2 = require("./server2.js");  导入自定义模块需要按照相对路径查找
            模块引入有缓存，即使引入多次，也是执行一次，走的是缓存
        require .cache[path.resolve("./a.js")];
            模块清除缓存,路径为绝对路径，cache是模块缓存信息对象 属性名是模块的绝对路径
    导出
        第一种导出方法
            module.exports.sum = sum;   导出自定义模块
            module.exports = {
                sum:sum,
                abc:abc
            };
        第二种导出方法
            module.exports = exports;  默认导出的都是module.exports指向的空间地址
            exports.name = "zhs";//给默认module.exports添加了一个属性
            exports = {//重新创建了一个空对象(地址），改变默认module.exports的空间地址，不能进行批量导出
                name :"zhs"
            };
        总结：module.exports可以导出批量，但是exports无法批量导出，原因是两者指向的空间地址不同
        每个js模块其实导出都是自己的module.exports这个模块
注意：
---
    第三方模块和内置模块只需要根据名称查找即可
    模块的查找方式是从当前的目录下一级一级向上查找，直到找到根目录为止
    第三方模块安装方法    npm install mime --save

## ajax创建封装
```
function createAjax(){
    if(window.XMLHttpRequest){
        var oAjax = new XMLHttpRequest();
    }else{
        if(new ActiveXObject("Microsoft.XMLHTTP")){
            var oAjax = new ActiveXObject("Microsoft.XMLHTTP");
        }else if(new ActiveXObject("Msxml2.XMLHTTP")){
            var oAjax = new ActiveXObject("Msxml2.XMLHTTP");
        }else if(new ActiveXObject("Msxml3.XMLHTTP")){
            var oAjax = new ActiveXObject("Msxml3.XMLHTTP");
        }
    }
    return oAjax;
}

let xhr = createAjax();
xhr.open("GET","",true);
xhr.responseType = "json";
xhr.onreadystatechange = function(){
    if(this.readyState===4 && /^2\d{2}$}/.test(this.status)){
        console.log(this.response);
    }
};
xhr.send();
```


# 20170511
## ajax
    async javascript  and xml   web交互技术异步获取局部刷新
    xml   与数据有关 （数据格式）
ajax步骤
---
    1,创建ajax对象
        var oAjax = new XMLHttpRequest();
    2,打开一个接口，建立链接通道
        oAjax.open("请求方式","请求地址","是否异步");
            请求方式：get，post，delete，head，put
                http请求方式
                    * get       从后端获取资源
                    * post      推送数据给后端
                    * delete    删除服务器端资源
                    * head      获取响应头
                    * put       更新服务端数据
                    get与post区别
                        1,缓存问题
                            get存在缓存问题
                                解决办法：只需要在请求url？_=随机数(Math.random())，时间戳(new Date().getTime())
                            post不存在缓存问题
                        2,传输数据大小
                            get
                                get是将需要发送后端的数据拼接到url？name=zhs&age=10 大小限制
                                标准浏览器 8kb
                            post
                                通过请求体向后台发送数据，没有大小限制
                                xhr.send(JSON.Stringify(数据));  数据格式为字符串
                        3,安全问题
                            前端数据处理方式
                                get     请求是将数据拼接到url后面，容易被url劫持
                                post    请求是将数据放在请求体中，比较安全
                            后端数据处理方式
                                获取get方式请求发送
                                    url.parse("文件路径",true).query;
                                获取post请求发送的数据
                                    var str = '';
                                    req.on("data",function(data){//接受前端请求体里发送的数据（数据是一点点发送的，不是整体发送过来）
                                        str+=data;
                                    });
                                    req.on("end",function(){
                                           console.log(str);//接收数据完毕之后执行end   str属于string类型
                                           JSON.parse(str);  将字符串转换为对象
                                    });
            请求地址：url/接口
            是否异步：true 异步（async）    false 同步(sync)
    3,监听ajax请求状态
        oAjax.onreadystatechange = function(){
            ajax状态 0 - 4   readyState
                * 0 uninit 未初始化 创建了ajax对象 但没有调用open
                * 1 loading 载入 发送请求 调用了open和send
                * 2 loaded 载入完成 接受响应原始数据完成 准备解析
                * 3 交互 将响应回来的原始数据 解析为 客户端 可以调用的数据挂载到responseText responseXML
                * 4 done 完成  可以供客户端调用 并且http状态码为200
            if(this.readyState===4 && /^2\d{2}$/.test(this.status)){
                console.log(this.responseText);
            }
        };
    4,发送请求
        oAjax.send();

        JSON.stringify(obj);  将对象转化为字符串
        JSON.parse(str);    将字符串转换为对象

Jquery ajax参数分析
---
    $.ajax({
        url:url, //请求地址
        type:"GET", //请求方式    JQ1.9版本以下用method
        beforeSend:function(xhr){
          //发送请求之前  触发
        },
        data:{
            //向服务端发送的数据
        },
        cache:true, //是否缓存，true 缓存   false不缓存
        async:true, //是否异步,true 异步  false  同步
        jsonp:"",//重写jsonp的请求url中回调函数key的名称
        jsonpCallback:"",//指定jsonp回调函数的名称
        dataType:"text", //接受的数据解析格式  xhr.responseText
        context:window,//指定success里面上下文this
        success:function(result){ //成功的回调函数
            console.log(result);
            //this默认指向  当前options
        },
        timeout:3000,//设置请求超时时间，如果超时会触发error  xhr.timeout  触发  xhr.ontimeout = function
        error:function(err){    //请求出错
            console.log(err);
        },
        complete:function(xhr){
            //不管提交成功与否，都会执行
        }
    });

对象合并
---
    es6方法
        Object.assign(obj1,obj2);   obj2对象的内容会覆盖obj1

    for(var attr in obj2){
        obj1[attr] = obj2[attr];
    }

# 20170513
    什么是node？
        node就是一个运行环境，可以用js运行在服务端，浏览器端不能操作本地文件
    node特点（js是单线程）
        非阻塞异步I/O
        commonjs规范(node自带的模块化)
            require()  引入模块
            module.exports   导出模块
        基于V8引擎(浏览器端分为js引擎和webkit渲染引擎)
        npm 包管理器(bower)

    node安装
        Mac  安装 homebrew
            在终端输入下面安装 Homebrew
        查看是否安装成功
            cmd  node -v
        配置系统环境变量
            右键计算机属性->高级系统设置->环境变量->系统变量->配置path->node安装路径
        node 进入交互模式解析器
            命令行中输入 node
            ctrl+c    退出
        webstorm 配置node环境
            settings  ->
            找到nodeJs and npm  ->
            将enable转为disable
    js文件运行方式
        webstorm中运行方式
            在文件中 右键 --run 文件.js
        cmd中运行方式
            cmd---在文件目录下打开cmd命令窗口----输入node 文件.js

    global  node环境下的全局对象
    this    node环境下的this是空对象
        原因是node运行的js代码最终是被包装在一个函数中，而不是放在全局中，所以this没有指向global

    node模块
        1,内置模块
            fs  文件系统模块
                fs.readFileSync("读取的文件","编码格式");   同步读取   默认格式buffer格式(二进制数据流格式)
                    同步函数基本上都有返回值
                fs.readFile("读取的文件","编码格式",function(err,result){
                    err 错误信息
                    result  读取到的结果
                    if(err){
                        throw Error(err);
                    }esle{
                        console.log(result);
                    }
                });     异步读取   异步读取基本上没有返回值

                fs.writeFile("文件路径","写入内容",{flag:w},function(err){
                    flag    w为默认参数，写入并将原有覆盖
                            a  在原有内容的基础上进行添加
                    encoding    指定写入的编码格式
                    写入的内容只有两种格式：string类型与buffer格式
                    console.log(err);
                }); 异步写入 向文件中添加内容

                fs.writeFileSync("文件路径","写入内容",{flag:w});   同步写入

            http模块  搭建server
                http.createServer(function(req,res){
                    req 代表客户端请求对象
                        req.url  请求路径
                        req.method  获取提交方式

                    res 代表服务端响应对象
                        res.end(); 结束响应并可以返回一些信息回送给客户端（类型只能为字符串与buffer）
                        res.setHeader("Content-Type","text/html;charset=utf-8");设置返回给客户端的界面信息(字符编码格式，mime类型)
                        res.statusCode    修改状态码
                }).listen(端口,function(){
                    端口范围    0~65535
                    console.log("监听端口");
                });

                http-server
                    全局安装
                        npm install http-server -g
                        使用
                            在当前目录下打开命令行，输入http-server
                            http-server -p 8080     指定一个端口号（默认是8080）
            url模块
                url.parse(urlStr,true);
                    第二个参数默认为false，query会以&进行拼接显示数据，设置为true时，query会以对象的形式显示
            querystring模块
                qs.parse(字符串,"分隔符");       将字符串转化为对象
                qs.stringify(对象,"拼接符");     将对象转化为字符串
        2,第三方模块
            通过npm下载的模块
                npm安装save区别
                    代码依赖/生产依赖
                        npm install vue --save
                    开发依赖
                        npm install webpack -save
            查找机制：从当前文件夹开始查找，找不到，向上级查找，一级一级查找，直到根目录为止
                console.log(module);
                paths:
                   [ 'E:\\node\\node\\20170513\\node_modules',
                     'E:\\node\\node\\node_modules',
                     'E:\\node\\node_modules',
                     'E:\\node_modules' ] }
        3,自定义模块
            自己创建的js文件
            文件与文件之间的依赖(如a与b文件)
                b文件引入a文件
                    b文件
                        require("./a.js");  根据路径引入
                    a文件
                        module.exports.sum = sum;  导出a文件中的方法
                        console.log(this===module.exports);//true

# 20170514
## ！！！！ES6
    跨域
        同源策略 --- 限制XMLHttpRequest请求（src,href等不存在跨域）
            协议，域名，端口三者一致
            三者只要有一个不同就是跨域
            主要存在于两个页面交互中，url不同
jsonp原理
---
    客户端设置跨域
    利用script标签不存在跨域，我们给src属性url地址，只要能找到就会将js引入进来
    我们把请求的url地址设为script标签的src属性，并且和后台定义的一个字段，将我们全局中的函数名传给后台 cb=callback
    jsonp跨域只支持get请求

    CORS跨域资源共享，需要服务端设置
        res.setHeader("Access-Control-Allow-origin","*");
            * 代表任何人
            "http://localhost:6000"  单独设置某个服务跨域


# 20170516
## VUE
    vue    渐进式框架   MVVM模式
模式
---
    MVC ----- angularJs  ---- 单向通信
        model   数据层 保存数据
        view    视图层 用户界面
        controller  控制器 业务逻辑
        过程：v-c-m-v
            视图层：用户操作界面通过DOM事件--->
            控制器：向控制器发送指令，执行相应的业务逻辑，--->
            数据层：通过数据层保存或者修改状态，--->
            视图层：再由数据层反馈给视图层
    MVVM  ----- VUE  ----- 双向数据绑定
        m   model   数据模型 保存数据
        v   view    视图层 用户界面
        vm  viewModel   视图模型(将视图和数据绑定在一起)
        过程：
            v -> vm - m
            m -> vm - v
            1,view改变，会导致vm改变，vm改变了会同种model数据源状态
            2,m数据源更新了，会通知vm，vm发生改变，v会自动跟着变化

vue安装
---
    初始化一个package.json
        nmp init -y
    下载vue
        nmp install vue --save

## VUE
    vue压缩和不压缩
            开发版：通常开发阶段 引入不压缩版  有报错提示 便于调试
            生产版：压缩版 vue.min.js  是没有报错提示的

初始化vue
---
    初始化一个Vue的根实例，它需要一个参数对象，挂载元素el  数据data， 方法，生命周期钩子 template
```
var vm = new Vue({
    el:"#app",  挂载元素  指定应用范围 不能挂载在html或者body上
    data:{  数据，挂载数据 相当于viewModel
        title:"hello vue.js"
    }
});
```

认识Vue
---
    1,vm根实例会暴露出一些属性和方法  前面$
        console.log(vm.$data===obj);
            true 两者指向同一空间地址
        obj.title = "hello,zhs";
        vm.say = "hello,tong";
            不能再实例生成后添加不存在的属性，可以提前定义属性，后赋值

    2,console.log(vm.$el);  //<div id="box"></div>
        获取挂载元素 相当于document.getElementById("box");
        console.log(vm.$el===document.getElementById("box"));  true


    3,vm.$watch("title",function(newVal,oldVal){
        监听数据状态方法
            参数1是新值，参数2是旧值，监听的数据改变的时候触发，并且将新值和旧值当做参数传递进来
        console.log(newVal,oldVal);
    });

    4,vm.$mount("#box");
        手动指定挂载元素（如果在初始化vue实例时，没有设置el，可以通过以下方法进行挂载）

    5,模板语法
        1：编译模板方式
            {{ val }}   在html中插入值
                可以在{{}}进行表达式操作
                    三目运算符
                        {{ context?context:"没有值存在" }}
                        {{ context=context||"没有值存在" }}
                    简单运算
                        <h5>{{ num+100 }}</h5>
                    一些表达式
                        <h6>{{ text.toUpperCase() }}</h6>
                        <h2>{{ arr.join().slice(2) }}</h2>


                不可以在{{}}中使用的内容
                    不能使用操作语句
                        {{ var name = 100 }}
                        if判断 {{ if(true){title} }}

            <标签 v-text="val"></标签>  采用这种方式是避免了闪烁，看不到编译前的内容
                会将元素原有的内容替换掉
        2：v-cloak避免了闪烁，也可以使用双花括号插入值
        3：插入html片段  尽量少用，避免xss攻击
            <div v-html="htmlStr"></div>
        4:动态绑定属性  v-bind
            完整写法：<a v-bind:href="link">百度</a>
            简写:<a :href="link">百度</a>
        5,模板语法分析
            <div id="box">{{ title }}</div>
            <script>
                var oBox = document.getElementById("box");
                var title = "hello world";
                var reg = /\{\{(.*)\}\}/;
                var html = oBox.innerHTML;
                html = html.replace(reg,function(){
                    console.log(arguments[1]);
                    return eval(arguments[1]);
                });
                oBox.innerHTML = html;
            </script>

    6,v-for
          要循环谁，就把v-for写在谁身上
          in可以换成of
              v-for="val of arr"
          获取索引值
              遍历数组
                  v-for="(每一项内容,每一项索引) in arr"
              遍历json对象
                  v-for="(属性值,属性名) in json"
              遍历二维数组（既包含数组有包含对象）
                  item代表数组中的每一项
                  <li v-for="item in result">{{item.name}}:{{item.age}}</li>

    7,v-if  操作DOM元素
       true    插入
       false   移出

    8,v-show  操作元素样式显示隐藏
       true    显示
       false   隐藏

    9,v-once  一次性插入
       <div v-once>{{text}}</div>

    10,v-model
        v-model 应用于表单中做双向数据绑定，文本框radio,checkbox,select,textarea
        以下为常见的几种v-model的使用情况
            <!--第一种情况-->
                <input type="text" v-model="name" />
                <p>{{name}}</p>
            <!--第二种情况-->
                <input type="checkbox" v-model="val" />
                <p>{{val}}</p>
            <!--第三种情况-->
                React:<input type="checkbox" value="A" v-model="arrs">
                Vue:<input type="checkbox" value="B" v-model="arrs">
                Node:<input type="checkbox" value="C" v-model="arrs">
                <p>{{arrs}}</p>
            <!--第四种情况-->
                用户名：<input type="text" v-model="user.name">
                电话：<input type="text" v-model="user.tel">
                <ul>
                    <li>{{user.name}}</li>
                    <li>{{user.tel}}</li>
                </ul>

            new Vue({
                el:"#box",
                data:{
                    name:"",
                    val:"",
                    arrs:[],
                    user:{
                        name:"",
                        tel:""
                    }
                }
            });
    11,v-on 绑定事件
        完整写法：v-on:事件类型="处理函数";
        简写：@click = "处理函数";
        <button v-on:click="say('abc',$event)">点击</button>
            1,函数不传递参数是可以不加括号
            2,不传参数的情况下，默认第一个参数就是事件对象$event
        new Vue({
            el:"#box",
            methods:{   当前视图用到的方法存放在methods  存在事件的方法 集合
                say:function(e,event){
                    console.log(this);   this指向当前vue根实例
                    console.log(event.target);  获取触发事件的元素
                }
            }
        });
数组方法
---
    1, 查找id为2的那一项，如果找到那一项，会将那一项返回出去
        arr.find(function(item){
            return item.id === 2;
        });
    2,将符合条件的项过滤出来
        arr.filter(function (item) {
            return item.id>2
        });
    3,会将每一次的返回值作为新数组中的每一项，常用来修改一个数组的内容
        arr.map(function(item){
            if(item.id===2){
                return {id:20}
            }
            return item;
        });
# 20170517
## git安装
    git更新课件
        git pull origin master

    git拷贝项目到本地
        在新建目录下右键 git bash
        输入 git clone 地址

事件修饰符
---
    1,阻止冒泡传播,在事件后面添加stop即可
        原生方式：通过event对象下event.stopPropagation();
        v-on:click.stop = "clild";
    2,阻止默认行为,在事件后添加prevent即可
        原生方式：通过event对象下event.preventDefault();
        v-on:click.prevent = "link";
            a标签默认行为
                <a href="http://www.baidu.com" @click.prevent.stop="link">百度</a>
            表单默认行为
                原生方式：onsubmit = "return false";
                vue方式：
                    先阻止表单默认行为，在进行ajax操作
                    <form action="http://www.baidu.com"  @submit.prevent>
                        <button type="submit">提交</button>
                    </form>

    3,既阻止冒泡，又要阻止默认行为，在事件后进行串联即可
        @click.prevent.stop="link"
    4,将事件流机制有冒泡转为捕获
        @click.capture="center";
    5,一次性事件，事件只触发一次 --- 支持vue版本2.1以上
        @click.once="once";

按键修饰符
---
    1,根据某个按键触发事件,可以用@keyup.键值
        <input type="text" @keyup.enter="fn">
        <input type="text" @keyup.keyCode="fn">
        vue封装的几个常用按键
            @keyup.enter    回车
            @keyup.space    空格
            @keyup.esc      ESC
            @keyup.delete   delete
            @keyup.tab      tab
            @keyup.up       上
            @keyup.down     下
            @keyup.left     左
            @keyup.right    右
        自定义按键
            定义：Vue.config.keyCodes.q = 81;
            使用：<input type="text" @keyup.q="fn">

style与class
---
    1,操作style
        动态绑定样式
            对象写法 {key:"value"}
                <div v-bind:style="{width:'100px',height:'100px',backgroundColor:'red'}"></div>
                <div v-bind:style="styleObj"></div>
                    将styleObj对象存在vue.data中
            数组写法
                <div v-bind:style="[styleObj,styleObj2]"></div>
                    在vue.data中存放两个样式对象，在使用时用数组
    2,操作class
        动态绑定class   (动态绑定的class可以与静态class共存)
            <div :class="s1"></div>
                前提将class名称存在vue.data中

            对象写法
                class名称：布尔值(如果为true选用当前class名，如果为false不选择当前class名)
                <div :class="{style1:isActive,style2:!isActive}">对象写法</div>
            数组写法
                <div :class="[s1,font]"></div>  s1与font此时data对象中定义的属性名称
                <div :class="['style1','font']"></div> 还可以直接放字符串（即class名）
                可以进行三元运算
                    <div :class="[isActive?s2:s1]">三元运算写法</div>

            对象+数组写法
                <div :class="[{style1:!iActive,style2:isActive},'font']">对象+数组写法</div>

computed    计算属性
---
    computed通过一个属性计算出来一个新的属性，当这个属性变化时，新的属性也会跟着变化

    computed中的内容是函数，正常该函数分为两种状态，getter和setter
        如果只有一个函数时，默认采用get
        computed:{
            函数名称：{
                get:function(){
                    函数获取的时候会触发 get
                },
                set:function(){
                    函数的属性值被修改时被触发 set
                }
            }
        }

watch
---
    watch   监听属性 监听一些数据的状态
        new Vue({
            el:"#box",
            data:{
                val:"",
                title:"",
                obj:{name:"zhs",age:20}
            },
            watch:{
                val:function(newVal,oldVal){},
                title:"listen",
                obj:{
                    handler:function(newVal,oldVal){},
                    deep:true
                }
            }
            methods:{
                listen:function(newVal,oldVal){}
            }
        });
lifecycle
---
    lifecycle   生命周期    钩子函数
        实例状态
            beforeCreate:function(){
                实例创建前
            }
            created:function(){  请求数据在这个阶段
                实例创建完成
            }
        数据状态
            beforeMount:function(){
                数据挂载前
            }
            mounted:function(){
                数据挂载完成
            }
        实例销毁
            beforeDestroy:function(){
                销毁前
            }
            destroyed:function(){
                销毁完成
            }
            vm.$destroy();  销毁组件 实例  通过这个方法触发销毁
        data状态 更新
            beforeUpdate:function(){
                数据更新前
            }
            updated:function(){
                数据更新完成
            }
过滤器
---
    定义：
        自定义过滤器必须放在生成实例之前
        Vue.filter("过滤器名称",function(val){
            arguments参数
            默认第一个参数是当前的值
            return  结果;
        });
    使用：
        {{ message|过滤器名称 }}

什么是组件？
---
    组件是vue的一个强大功能，扩展html元素 代码重复利用

    组件分类
        全局组件 ------ 可以应用于各个el范围
            初始化实例前注册组件
                    组件名称：小写，可以是多个单词my-component，可以是单个单词comp,不能与原始标签名重复
                    参数对象；配置组件的结构（template），行为（methods），数据（data函数） ,计算属性，生命周期
            使用template标签创建模板，将模板标签id放在对象template属性后即可调用
                <template id="temps">
                    <div>
                        <h3>我是全局模板，欢迎使用</h3>
                    </div>
                </template>
                template:"#temps",
            注册：
                Vue.component("组件名称",{
                    template:"<h3 @click='say'>{{title}}</h3>",
                        template组件中只能有一个根元素
                    data:function(){    此data不是对象，是函数
                       return {title:"我是一个组件"}   必须将数据返回
                    },
                    methods:{
                        say:function(){
                            alert(1);
                        }
                    },
                    computed:{
                    },
                    created:function () {
                        alert("创建组件完成");
                    }
                });
            使用：
                <组件名称></组件名称>
        局部组件  -----  只能应用于当前el的范围
            注册：
                new Vue({
                    el:"#box",
                    components:{
                        "自定义标签名":{
                            template:"<h1>我是一个局部组件</h1>"
                        }
                    }
                });
            使用：
                <自定义标签名></自定义标签名>

# 20170518
组件嵌套
---
    根实例被称之为父组件
    new Vue({
        el:"#box",
        如果根实例没有指定模板，默认会将div#box作为模板，如果定义了template模板，会将模板渲染在界面上，会替换div#Box
        template:"<div><h3>父组件图书商城</h3><child></child><child></child></div>",
        components:{
            child:{
                可以将子组件模板直接放入父组件模板中
                template:"<div><h4>子组件图书列表</h4><book1></book1><book2></book2></div>",
                components:{
                    book1:{
                        template:"<p>署名：vue.js <end></end></p>",
                        components:{
                            end:{
                                template:"<div><button>购买</button></div>"
                            }
                        }
                    },
                    book2:{
                        template:"<p>署名：react.js<end></end></p>",
                        components:{
                            end:{
                                template:"<div><button>购买</button></div>"
                            }
                        }
                    }
                }
            }
        }
    });

父组件向子组件通信   ----  props
---
    子组件不可以直接使用父组件的数据
        props 用来从父组件传递数据给子组件


    <child mess="zhs"></child>
        子组件外部传递数据 自定义mess="zhs"  数据是string类型的
    <child v-bind:mess="title" my-data=""></child>
        v-bind:mess  是将数据作为变量来处理，而不是字符串

    var child = {
        props:["mess","myData"], 指定一个传递的数据属性,用来接收传递进来的数据属性，如果属性名是驼峰命名，在外部使用的时候全小写 “-’隔开
        template:"<div><h3>{{mess}}</h3></div>"
    };
    new Vue({
        el:"#box",
        data:{
            title:"parentData"
        },
        components:{
            child:child
        }
    });

    VUE单向数据流
        props：单向数据流
            vue中父组件可以修改子组件的数据，当父组件的数据发生变化，子组件也会变化
            但是子组件无法改变父组件 ，否则就会提示警告

            需求1：将父组件的数据变为子组件的私有数据（为了解决当修改子组件的数据修改时，会有提示警告的问题？）

                父组件传递给子组件初始数据，一旦接收到数据，就会将当前得到的数据作为子组件的私有局部数据
                <input type='text' v-model='message'>
                data:function(){
                    return {message:this.mess};
                }
            需求2：一旦父组件的数据发生变化，子组件时时接受数据，即不需要存储数据，直接引用props中的属性即可
                <input type='text' v-model='mess'>

            需求3：父组件传递给子组件的数据进行处理，处理后作为局部数据，依然也可以和父组件的数据状态同步,同时不会有警告
                <input type='text' v-model='comps'>
                computed:{
                    comps:function(){
                        return this.mess.toUpperCase();//对父组件传递进来的数据进行处理
                    }
                }

props参数
-------
```
<child mess="hello"></child>
<child :mess="1"></child>
不接受外部的数据 default默认值才会生效
<child></child>
<child :mess="100"></child>
new Vue({
    el:"#box",
    data:{
        title:"哈啊"
    },
    components:{
       child:{
           template:"<div><h3>{{mess}}</h3></div>",
           props方式一：
                props:["mess"],

           props方式二：
               props:{
                   指定传递的类型，能够验证的类型：string，boolean,function,array,object,number
                   mess:Boolean,
                   mess:[Boolean,Number]    可以指定多个类型
                   mess:{   验证多项
                       type:Number,
                       type:[Number,String],    多个类型
                       type:Object,
                       default:function(){
                          return {val:"默认值"}
                          给一个对象或者数组设置默认值时，需要以函数的形式进行设置
                       }
                       default:"这是什么都没有写的情况下显示的内容", ----- 默认值
                       required:true,
                            如果为true是指当前mess是必传项，默认值与必传项是不能共同使用的
                       validator:function(val){ ----- 验证函数
                            console.log(val);
                            return val>50;
                            如果返回值为true，警告会消失，返回false会出现警告
                       }
                   }
               },

       }
    }
});
```
子组件向父组件通信   $emit
---
    监听自定义事件，在点击按钮触发自定义事件，调用父组件定义的answer函数，来接受子组件传递过来的数据
    <child v-on:getclothes="answer"></child>

    触发器 $emit 发布自定义事件
    var child = {
        template:"<div><h3>子组件</h3><input type='button' value='child说' @click='say' /><p>{{message}}</p></div>",
        data:function(){
            return {message:"准备发布"}
        },
        methods:{
            say:function(){
                this.message = "下雨啦，赶紧收衣服";
                this.$emit("getclothes",this.message); 发布$emit(自定义事件,子组件传递的消息);
                自定义事件名称不能出现大写
            }
        }
    }
    new Vue({
        el:"#box",
        data: {
            title: ""
        },
        components:{
            child
        },
        methods:{
            answer:function(val){
                console.log(val);
                this.title = val;
            }
        }
    });

子组件与子组件之间通信
---
    <h3>老大</h3>
    <prevsibling></prevsibling>
    <h4>老二</h4>
    <nextsibling></nextsibling>

    //$emit发布     $on监听
    let cpc = new Vue(); //中间人，负责传递数据
    var prevsibling = {
        template:"<div><button @click='say'>老大说</button></div>",
        methods:{
            say:function(){
                cpc.$emit("warning","我是老大，你得听我的");
            }
        }
    };
    var nextsibling = {
        mounted:function(){
            cpc.$on("warning",this.listen); //在数据挂载完成之后，开始监听
        },
        data:function(){
            return {message:"等待通知"};
        },
        template:"<div><p>接收到的通知:{{message}}</p></div>",
        methods:{
            listen:function(val){
                this.message = val;
            }
        }
    };
    new Vue({
        el:"#box",
        components:{
            prevsibling:prevsibling,
            nextsibling:nextsibling
        }
    });

slot  分发内容  分放内容  分配位置
---
    template会将child标签的内容覆盖掉，如果里面内容了，也会被覆盖掉;
    如果想要保留原有内容，可以通过<slot></slot>插入到模板相应位置中
    如果希望将模板内容放在原有布局中某一个位置，可以通过如下操作

    模板内容如下：
        <div>
           <slot name='header'></slot>
           <p>这是一个主体内容</p>
           <slot></slot>
        </div>

```
html如下：

 <child>
     <header slot="header">头部</header>
     <h3>标题</h3>
     <footer>头部</footer>
 </child>
```

# 20170523
is
---

    指定模板（组件）插入位置  需要与<component is="组件名"></component>配合使用
        <component is="users"></component>  users是字符串
        <component :is="comp"></component>  comp是变量名

        keep-alive  缓存组件状态，避免每一次切换组件重新渲染
        <keep-alive>
            <component :is="comp"></component>
        </keep-alive>

        new Vue({
            el:"#box",
            data:{
                comp:"users",
            },
            components:{
                users:{
                    template:"<div><input type='text' v-model='val'></div>",
                    data:function(){
                        return {val:"hello user"};
                    }
                },
                books:{
                    template:"<div><input type='text' v-model='val'></div>",
                    data:function(){
                        return {val:"hello books"};
                    }
                }
            }
        });

vue插件
---
    vue全家桶
        vue-cli 脚手架
        vue2
        vue-resource
        vue-router
        vuex    管理vue组件状态
        基于vue的ui

vue-resourse    请求数据
---
    全局中请求:Vue.http
    局部中请求:实例.$http

    get请求
        this.$http.get(url,{params:{key:value}).then(success,error);
            this指向当前实例
    post请求
        this.$http.post(url,{key:value}).then(success,error);
    jsonp跨域请求
        this.$http.get(url,{params:{
            key:value,
            jsonp:"cb",     cd=函数名，默认函数名是callback
            jsonpCallback:"fn"  指定函数名是什么
        }).then(success,error);
        可以自定义函数名称，与后台接口要一致
vue过渡动画
---
    animate.css 动画库
    动画名称-enter  指定进入过渡开始状态
    动画名称-enter-active   指定进入过渡激活结束状态
    动画名称-leave  指定离开过渡开始状态
    动画名称-leave-active   指定离开过渡结束状态
    使用方式：
        .name-enter{
            opacity:0;
        }
        .name-enter-active{
            transition:all 0.5s;
        }
    <transition name="动画名称">
        将需要动画的内容放在transition标签中
    </transition>

    vue中使用animate.css自定义动画
        enter-active-class后面指定animate.css中的进入动画class名称即可
        leave-active-class后面指定animate.css中的退出动画class名称即可
        <transition enter-active-class="animated hinge"  leave-active-class="animated hinge">
            <h3 v-show="flag">这是结合animate.css的自定义动画</h3>
        </transition>

vue-router  路由
---
    什么是路由？
        在一个页面中，根据切换导航展示相应内容，局部刷新，不需要跳转，重新加载整个页面
        spa 使用路由实现单页应用:所有事情都在一个页面中操作

        配置路由导航布局
            <router-link to="路由路径">导航名称</router-link>  -----  其实就是a标签
            <router-view></router-view>     路由视图

        路由创建步骤
            1,创建组件
                let 组件名称 = {
                    template:"模板内容"
                };
            2,配置路由表  路由规则   路由路径映射组件  必须是数组
                var routes = [
                    {path:"路由路径",component:组件名称},
                    {path:"*",redirect:"/index"} 重定向到存在的路径，默认显示的路由，*代表除以上路径的所有路径
                ];
            3,创建路由实例
                let VRouter = new VueRouter({
                    routes:路由规则数组名
                });
            4,在根实例中注入路由  router:将创建的路由实例赋给根实例即可
                  new Vue({
                      el:"#box",
                      router:VRouter
                  });

路由嵌套，可以通过template标签
---
    <template id="index">
        <div>
            <h3>这是首页内容</h3>
            <h3>子路由</h3>
            <nav>
                <router-link to="/index/text1">子路由1</router-link>
                <router-link to="/index/text2">子路由2</router-link>
                <router-link to="/index/text3">子路由3</router-link>
            </nav>
            缓存修改过的内容，当切换组件的时候，不会刷新页面回到最初设置的内容
            <keep-alive>
                <router-view></router-view>
            </keep-alive>

        </div>
    </template>
    1,引入模板组件,创建子路由组件
        let Index = {
            template:"#index"
        };
    2,创建路由规则
        let routes = [
            {
                path:"/index",
                component:Index,
                children:[
                    {path:"text1",component:Text1},
                    {path:"text2",component:Text2},
                    {path:"text3",component:Text3}
                ]
            },
            {path:"/news",component:News},
            {path:"/images",component:Images},
            {path:"/music",component:Music},
            {path:"*",redirect:"/index/text1"}
        ];
    3,创建路由实例
        let Vrouter = new VueRouter({
            routes:routes
        });
    4,在根实例中注入路由
        new Vue({
            el:"#box",
            router:Vrouter
        });

# 2070524
## 动态路由
    
$route
---
```
$route  获取路由信息
$route.params   路由中传递的参数
$route.query    路由中?后面的查询参数

<router-link to="/user/12">user</router-link>
<router-link to="/books/24">books</router-link>

<template id="books">
    <div>
        <h3>图书列表</h3>
        <p>当前传递的ID {{$route.params.id}}</p>
    </div>
</template>

想要拿到12或者24
需要通过$route.params对象进行获取

let routes = [
    : 指定是路由参数 id  
        被存储在$route.params:{ id: 参数 }  
        实例中使用是 this.$route.params
    {path:"/user/:id",component:User},
    {path:"/books/:id",component:Books},
];

/index/12    params{id:12}
/index/zhufeng  params{id:'zhufeng'}    $route.params.id

/index/20/zhufeng   
/index/:id/:user    params{id:20,user:zhufeng}  $route.params.id/$route.params.user
```

new VueRouter()实例
---
提供了路由操作方法
```
beforeEach与beforeRouteEnter

全局方法  ---- beforeEach

var VRouter = new VueRouter();
VRouter.beforeEach(function(to,from,next){
    console.log(to);    要到哪个路径
    console.log(from);  从哪个路径开始
    next(); 路由切换之前可以做权限验证，控制路由是否继续切换 ，控制是否继续执行，也可以传递参数

    if(to.path==="/"){
        alert("你没有用户权限");
        next({path:"/user/20/zhufeng"});    切换到指定路由
    }else{
        next();     切换到其他相应路由
    }
});

局部方法   -----  beforeRouteEnter

let User = {
    template:"#user",
    computed:{
        uid:function(){
            return this.$route.params.id;
        }
    },
    beforeRouteEnter:function(to,from,next){  相当于beforeEach，只不过是局部的
        只有切换到当前的路由之前才会触发
        console.log(to);
        console.log(from);
        alert(to.params.id);
        next({path:"/books/24/zhs"});
        next(function(vm){
            console.log(vm);  可以传递回调函数，可以将根实例作为参数传递进来使用
        });

    }
};

push    切换到指定路由

全局方法  ---- push
VRouter.push();     切换到指定路由  记录histrory管理记录

<button @click="returnback">返回到首页</button>
var vm = new Vue({
    el:"#box",
    router:VRouter,
    methods:{
        returnback:function(){
            VRouter.push("/");
        }
    }
});


局部方法 ---  push
this.$router.push('/'); 切换到指定路由
this.$router.repalce('/') 切换到指定路由 
两者展示效果一样，但是replace不会被记录到history管理记录中

<button @click="back">返回首页</button>
methods:{
    back:function(){
        this.$router.push('/');
    }
}

go  控制页面前进后退   window.history.go

全局方法
VRouter.go(-1);  

局部方法
this.$router.go("整数"); 控制页面前进后退 
    大于1，前进到上一个页面  小于1 后退到上一个页面
```

## 动态绑定路由方法

```
<router-link :to="indexRoute">首页</router-link>
new Vue({
    el:"#box",
    router:VRouter,
    data:{
        indexRoute:{path:'/index/20',query:{name:'zhs'}}
    }
});
```

## 命名路由

```
<!--命名路由  name代表相应的路径-->
<router-link :to="{name:'index', params:{uid:24},query:{user:'zhs'}}">首页</router-link>
<router-link :to="{name:'video', params:{uid:40},query:{user:'tl'}}">视频</router-link>
<router-view></router-view>

<!--路由规则设置-->
let routes = [
    {path:"/index/:uid",name:"index",component:Index},
    {path:"/video/:uid",name:"video",component:Video}
];
```

## 监听路由

```
new Vue({
    el:"#box",
    router:VRouter,
    watch:{
        "$route":function(to,from){  //监听路由   监听路由信息
            console.log(arguments);
            console.log(this);
        }
    }
});
```

## vue 单文件组件

    自定义的后缀是.vue文件，一个文件就是一个组件，(包含功能，结构，样式，数据状态...)

    如果想使用vue单文件组件，需要借助编译工具  webpack browserify编译成可以识别的

### 后缀为.vue文件书写规范

```
第一部分：
<template>
    <div id="box">
        <h3 @click="say">{{title}}</h3>
    </div>
</template>
第二部分：
<script>
    export default{
        data(){
            return {title:"今天星期四"};
        },
        methods:{
            say:function(){
                alert(1);
            }
        }
    }
</script>
第三部分：
<style>
    h3{
        color:#ccc;
    }
</style>
```

### 如何使用单文件组件？
- 导入vue模块
- 在main.js中导入.vue单文件组件
- import 给.vue文件的名称 from ".vue文件路径"
- 声明一个Vue实例
- 在实例中注册组件

```
import Vue from 'vue'  
import App from './App.vue' 

new Vue({
  el: '#app',
  components:{ 
      App,
      Hello,
      Zhs
  }
});
```

## vue-cli  
- vue脚手架：将基本的环境搭建好，然后我们基于这个环境开发
- 安装vue-cli  
```
npm install vue-cli -g
vue list    查看模板参数
vue init <template-name> <project-name>   初始化vue项目
    eg:vue init webpack-simple(依赖的模板) myvue(项目名称)
    模板类型
        browserify
        browserify-simple
        pwa
        simple 
        webpack 
        webpack-simple 

运行项目

cd myvue    进入项目目录
npm install 安装依赖文件
npm run dev 开启server
```

# 20170525
## webpack   构建工具
### 安装webpack  
- 全局安装  可以在cmd中使用
```
nmp install webpack -g 
```
- 项目依赖中安装webpack
```
npm install webpack --save-dev/-D    开发依赖
```
- 在当前目录下创建webpack配置文件 --- 
```
webpack.config.js   默认名
```

### 开发环境部署
- 安装webpack-dev-server
```
npm install webpack-dev-server -g   基于express
```
- 项目中安装依赖
```
npm install webpack-dev-server --save-dev
```
- 在项目根目录创建index.html
- 引入编译后的文件
- 命令窗口运行webpack-dev-server
```
webpack-dev-server 回车即可
```
- 开发调试结束后,cmd中输入命令，生成dist目录
```
webpack 
```

## package.json 指定运行脚本
```
"scripts": {
    //通过webpack-dev-server自动打开默认浏览器，时时监控外部文件的变化
    "dev":"webpack-dev-server --open --hot" ,  ---- 开发阶段
    "build":"webpack --progress --hide-modules"  ---- 生产阶段
},
```

## 手动指定配置文件
- 默认会自动找webpack.config.js,但是如果有多个配置文件，可以手动指定
- webpack-dev-server --config  webpack.config1.js
- 可以将手动指定配置文件的代码写入package.json中
```
{
  "name": "web",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev":"webpack-dev-server --config webpack.config1.js --open --hot",
    "build":"webpack --progress --hide-modules"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^2.6.0",
    "webpack-dev-server": "^2.4.5"
  }
}
```


### webpack.config.js分析
- __dirname是指当前文件所在目录的绝对路径
- __filename是指当前文件的绝对路径
- path.resolve(__dirname,"./dist");   路径模块,将编译后的文件接解析出绝对路径
- path.join(__dirname,"./dist");    路径模块,将解析出来的绝对路径与dist文件拼接在一起
- 配置文件完成后，在当前目录下打开cmd，输入webpack进行编译
```
let path = require("path"); //node中操作路径模块，可以拼接，可以解析
//需要导出的配置对象
module.exports = {
    //需要编译的文件入口
    entry:"./src/index.js",
    //编译后的文件输出出口
    output:{
        //指定编译后的输出路径(绝对路径)
        path: path.resolve(__dirname,"./dist"),
        //指定编译后的文件名  "[name].js"-->默认编译后是main.js
        filename:"bundle.js",
        //手动指定server资源输出后的存放路径,不写默认是根路径/
        publicPath:"/dist/" 
    }
};
```



